#!/usr/bin/env python3
# --------------------( LICENSE                            )--------------------
# Copyright (c) 2014-2023 Beartype authors.
# See "LICENSE" for further details.

'''
Project-wide **path removers** (i.e., low-level callables permanently removing
on-disk files and directories in various reasonably safe and portable ways).

This private submodule is *not* intended for importation by downstream callers.
'''

# ....................{ IMPORTS                            }....................
from beartype.roar._roarexc import _BeartypeUtilPathException
from beartype._data.datatyping import (
    PathnameLike,
    PathnameLikeTuple,
)
from importlib.machinery import BYTECODE_SUFFIXES
from pathlib import Path

# ....................{ REMOVERS                           }....................
#FIXME: Unit test us up, please.
def remove_package_bytecode_files(package_dirname: PathnameLike) -> None:
    '''
    Permanently and silently remove all **bytecode files** (i.e., pure-Python
    bytecode compiled to platform-dependent temporary files residing in
    temporary ``__pycache__/`` subdirectories) of the passed package.

    Usage
    ----------
    This function is typically intended for usage in our test suite. Unit tests
    exercising :mod:`beartype` functionality that dynamically modifies the
    contents of bytecode files guarantee idempotency (i.e., reproducibility) by
    calling this function *before* exercising that functionality. Examples
    include :mod:`beartype.claw` import hooks that dynamically transform the
    abstract syntax trees (ASTs) of sample modules embedded in our test suite
    *before* permanently serializing (i.e., saving, writing) those changes back
    to disk within those bytecode files. Preventing desynchronization between
    the frequently changing implementations of those import hooks and those
    bytecode files requires calling this function beforehand.

    Caveats
    ----------
    **This function is subject to subtle race conditions if multiple threads
    and/or processes concurrently attempt to mutate this ``__pycache__/``
    subdirectory.** Since *all* filesystem-centric logic suffers similar issues,
    we leave this issue as an exercise for the caller.

    Parameters
    ----------
    package_dirname : PathnameLike
        Absolute dirname of the package to remove all previously compiled
        bytecode files from.
    '''
    assert isinstance(package_dirname, PathnameLikeTuple), (
        f'{repr(package_dirname)} neither string nor "Path" object.')

    # High-level "Path" object encapsulating this dirname.
    package_dir = Path(package_dirname)

    # High-level "Path" object encapsulating the "__pycache__/" subdirectory
    # directly contained in this parent directory.
    pycache_dir = package_dir / '__pycache__'

    # If this parent directory contains *NO* "__pycache__/" subdirectory,
    # silently reduce to a noop.
    if not pycache_dir.is_dir():
        # print(f'Package "{package_dir}" bytecode directory "__pycache__/" not found.')
        return
    # Else, this parent directory contains a "__pycache__/" subdirectory.

    #FIXME: Optimize us up by refactoring this O(n) loop into a single O(1)
    #call. How? By generating a new glob expression matching *ALL* bytecode
    #suffixes simultaneously. Since this function is currently *ONLY* called
    #from test suite, efficiency is currently mostly irrelevant. Ergo, we
    #currently ignore this microoptimization in favour of brute force ignorance.

    # For the "."-prefixed filetype of each type of platform-dependent bytecode
    # file generated by the current platform...
    for BYTECODE_SUFFIX in BYTECODE_SUFFIXES:
        # print(f'Removing package "{pycache_dir}" bytecode files "*.{BYTECODE_SUFFIX}...')

        # Permanently and silently remove *ALL* bytecode files previously
        # compiled by Python into this "__pycache__/" subdirectory.
        #
        # Note that this filetype is already prefixed by ".". *sigh*
        remove_paths_globbed(dirname=pycache_dir, glob=f'*{BYTECODE_SUFFIX}')


#FIXME: Unit test us up, please.
def remove_paths_globbed(dirname: PathnameLike, glob: str) -> None:
    '''
    Permanently and silently remove *all* target files and empty directories
    from the source directory with the passed dirname matching the passed
    POSIX-compliant glob expression.

    Caveats
    ----------
    **This function raises an exception if this glob expression matches one or
    more non-empty directories.** Consider an alternate approach leveraging
    recursive directory tree traversal if requiring non-empty directory removal.

    **This function is subject to subtle race conditions if multiple threads
    and/or processes concurrently attempt to mutate this source directory.**
    Since *all* filesystem-centric logic suffers similar issues, we leave this
    issue as an exercise for the caller.

    **This function is currently inefficiently implemented in a single-threaded
    manner for simplicity.** This approach is appropriate when removing a small
    number of files but inappropriate when removing a large number of files. In
    the latter case, consider an alternate approach leveraging either
    multithreading or multiprocessing. See also this `popular article`_.

    .. _popular article:
        https://superfastpython.com/multithreaded-file-deletion

    Parameters
    ----------
    dirname : PathnameLike
        Dirname of the directory to remove *all* files and empty directories
        matching this glob from, specified as a **pathname-like** (i.e., either
        a low-level string possibly signifying a pathname *or* a high-level
        :class:`Path` instance definitely encapsulating a pathname).
    glob : str
        POSIX-compliant glob expression matching *all* files and empty
        directories to be removed from this directory (e.g., ``"*.jpg"``). Note
        that:

        * Recursive globbing is supported via the quasi-standard ``"**/"``
          syntax (e.g., ``"**/*.jpg"``, recursively removing all JPEG-formatted
          images from both this directory and all subdirectories of this
          directory).
        * Glob syntax otherwise corresponds to that supported by the standard
          :mod:`fnmatch` module.

    Raises
    ----------
    _BeartypeUtilPathException
        If either:

        * This directory does *not* exist.
        * This directory exists but is *not* actually a directory.

    See Also
    ----------
    https://stackoverflow.com/a/38189275/2809027
        StackOverflow answer strongly inspiring this implementation.
    '''
    assert isinstance(dirname, PathnameLikeTuple), (
        f'{repr(dirname)} neither string nor "Path" object.')
    assert isinstance(glob, str), f'{repr(glob)} not string.'

    # High-level "Path" object encapsulating this dirname.
    dirname_path = Path(dirname)

    # If this directory either does *NOT* exist or is *NOT* a directory, raise
    # an exception.
    if not dirname_path.is_dir():
        raise _BeartypeUtilPathException(
            f'Directory "{dirname_path}" either not found or not directory.')
    # Else, this directory is an existing directory.

    # For each matching pathname globbed from this dirname as a "Path" object...
    for pathname_globbed in dirname_path.glob(glob):
        # print(f'Removing globbed path "{pathname_globbed}"...')

        # If this pathname refers to a file...
        if pathname_globbed.is_file():
            #FIXME: Pass "missing_ok=True" *AFTER* dropping Python 3.7, as doing
            #so will improve the robustness of this logic against race
            #conditions.

            # Silently remove this file if feasible *OR* raise an exception.
            pathname_globbed.unlink()
        # Else, this pathname does *NOT* refer to a file.
        #
        # If this pathname refers to a (hopefully empty) subdirectory...
        elif pathname_globbed.is_dir():
            # Silently remove this empty subdirectory if feasible *OR* raise an
            # exception.
            pathname_globbed.rmdir()
        # Else, this pathname refers to neither a file *NOR* subdirectory. In
        # this case, silently ignore this pathname.
