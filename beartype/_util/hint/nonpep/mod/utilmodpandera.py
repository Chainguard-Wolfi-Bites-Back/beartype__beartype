#!/usr/bin/env python3
# --------------------( LICENSE                            )--------------------
# Copyright (c) 2014-2023 Beartype authors.
# See "LICENSE" for further details.

'''
Project-wide **PEP-noncompliant NumPy type hint** (i.e., type hint defined by
the third-party :mod:`numpy` package) utilities.

This private submodule is *not* intended for importation by downstream callers.
'''

# ....................{ IMPORTS                            }....................
#!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
# CAUTION: The top-level of this module should avoid importing from third-party
# optional libraries, both because those libraries cannot be guaranteed to be
# either installed or importable here *AND* because those imports are likely to
# be computationally expensive, particularly for imports transitively importing
# C extensions (e.g., anything from NumPy or SciPy).
#!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
from beartype.roar import BeartypeDecorHintNonpepPanderaException

# ....................{ REDUCERS                           }....................
def reduce_hint_pandera(
    hint: object,
    exception_prefix: str,
    *args, **kwargs
) -> object:
    '''
    Reduce the passed **PEP-noncompliant Pandera type hint** (i.e.,
    subscription of *any* PEP-noncompliant type hint factory published by the
    third-party :mod:`pandera.typing` type hint factory) to an arbitrary
    PEP-compliant ignorable type hint.

    Specifically, this reducer unconditionally ignores *all* type hints
    published by the :mod:`pandera.typing` subpackage. Why? Because Pandera
    publishes its own Pandera-specific PEP-noncompliant runtime type-checking
    decorator :func:`pandera.check_types` that supports *only* Pandera-specific
    PEP-noncompliant :mod:`pandera.typing` type hints. Since Pandera users are
    already accustomed to decorating *all* Pandera-based callables (i.e.,
    callables accepting one or more parameters and/or returning one or more
    values annotated by Pandera type hints) with :func:`pandera.check_types`,
    attempting to type-check the same objects already type-checked by that
    decorator would only inefficiently and needlessly slow type-checking
    wrappers generated by the :func:`beartype.beartype` decorator. Moreover,
    doing so is infeasible. Pandera type hints are extremely non-standard and
    thus *not* reasonably type-checkable by any standards-compliant static or
    runtime type-checkers. Ergo, we fallback to unconditionally ignoring *all*
    Pandera type hints.

    This reducer is intentionally *not* memoized (e.g., by the
    :func:`callable_cached` decorator), as the implementation trivially reduces
    to an efficient one-liner.

    Motivation
    ----------
    The core issue with Pandera type hints is somewhat more subtle than the glib
    hand-waving performed above. Yes, Pandera type hints *are* PEP-noncompliant,
    but they're more than just that. Pandera type hints fundamentally contravene
    established semantics for PEP-compliant generics. Generally speaking,
    generics are *not* simply descriptive type hints; they're full-blown classes
    intended to be instantiated as objects throughout the codebase using those
    generics as type hints. The unsubscripted portion of a generic hint is an
    instanceable class (e.g., the "list" in "list[str]" is itself an
    instanceable class). @beartype expects any object annotated by a generic
    type hint to be an instance of that generic: e.g.,

    .. code-block:: pycon

       # A PEP 585-compliant generic.
       >>> class ListOfStrings(list[str]): pass

       # An instance of this generic satisfies this generic used as a type hint.
       >>> from beartype import beartype
       >>> @beartype
       ... def accept_list_of_strings(lst: ListOfStrings): return 'Okie-dokie!'
       >>> accept_list_of_strings(ListOfStrings())
       'Okie-dokie!'

    Pandera type hints violate this expectation. Syntactically, Pandera type
    hints are PEP-compliant generics (of course); semantically, Pandera type
    hints are PEP-noncompliant generics, because the objects they describe
    (i.e., Pandas data frames) are *not* instances of these generics. Pandas
    data frames are instances of the Pandera-agnostic
    "pandas.core.frame.DataFrame" non-generic class rather than Pandera-specific
    "pandera.typing.pandas.DataFrame" generic.

    Pandera type hints *should* have been instead defined as PEP 544-compliant
    protocols that exploit ephemeral duck typing. Since they weren't, downstream
    consumers like @beartype must now pretend that Pandera type hints are the
    Pandas types they semantically alias by reducing the former to the latter.

    Caveats
    ----------
    **This reducer does not validate the callable annotated by this Pandera type
    hint to be decorated by the** :func:`pandera.check_types` **decorator.**
    Ideally, this reducer would do so to prevent :mod:`beartype` from emitting
    false positives and negatives from calls to callables for which the user
    accidentally omitted the :func:`pandera.check_types` decorator.
    Unfortunately, order of decoration is arbitrary. :mod:`beartype` has no
    means of distinguishing between these two cases:

    * The valid case in which the user decorated this callable first by
      :func:`beartype.beartype` and then by :func:`pandera.check_types`. In this
      case, :func:`beartype.beartype` runs first and has no efficient means of
      deciding that the :func:`pandera.check_types` will be run immediately
      after -- short of abstract syntax tree (AST) inspection, which would be
      extraordinarily inefficient, non-portable, and fragile.
    * The invalid case in which the user accidentally omitted the
      :func:`pandera.check_types` decorator.

    **This reducer does not validate that this Pandera type hint annotates a
    callable.** Technically, Pandera type hints are invalid in *all* type
    hinting contexts except as callable annotations -- including:

    * As a class type hint.
    * As an attribute assignment type hint.
    * As the type hint passed to a statement-level runtime type-checker (e.g.,
      :func:`beartype.door.is_bearable`).

    Pragmatically, refactoring :mod:`beartype` to inform reducers of whether or
    not the current hint (that may be a nested child type hint of a parent type
    hint) annotates a callable or not would be extraordinarily non-trivial.
    Doing so would require refactoring our low-level:

    * Code generators to accept an additional parameter describing this case.
    * Type hint reducers to transitively pass that same parameter here.

    Since Pandera type hints are already PEP-noncompliant, the only sane
    approach is to continue unconditionally ignoring them. Let us not break
    :mod:`beartype` for the PEP-noncompliant.

    Parameters
    ----------
    hint : object
        PEP-noncompliant typed NumPy array to return the data type of.
    exception_prefix : str
        Human-readable label prefixing the representation of this object in the
        exception message.

    All remaining passed arguments are silently ignored.

    Returns
    ----------
    object
        Arbitrary PEP-compliant ignorable type hint.

    Raises
    ----------
    BeartypeDecorHintNonpepPanderaException
        If either:

        * This hint is *not* a PEP 484- or 585-compliant generic.
        * This hint is a PEP 484- or 585-compliant generic *not* subclassing one
          or more Pandas-specific superclasses.
    '''

    #FIXME: Revise documentation above, please.
    #FIXME: Update return annotations above, please.
    #FIXME: Unit test us up, please.
    #FIXME: Extricate this logic into a new callable memoized by
    #@callable_cached for efficiency, please -- say:
    #    # In "utilpep484585generic":
    #    @callable_cached
    #    def get_hint_pep484585_generic_type_base_first_in_module(
    #        hint: object,
    #        module_name: str,
    #        exception_cls: TypeException,
    #        exception_prefix: str,
    #    ) -> type:
    #        '''
    #        First type in the method resolution order (MRO) of the
    #        unsubscripted generic type underlying the passed possibly
    #        subscripted PEP 484- or 585-compliant generic type hint.
    #        '''

    # Avoid circular import dependencies.
    from beartype._util.hint.pep.proposal.pep484585.utilpep484585generic import (
        get_hint_pep484585_generic_type)
    from beartype._util.mod.utilmodget import get_object_module_name_or_none

    # Either:
    # * If this Pandera generic is unsubscripted, this unsubscripted generic
    #   type as is.
    # * If this Pandera generic is subscripted, the unsubscripted generic type
    #   underlying this subscripted generic (e.g., the type
    #   "pandera.typing.pandas.DataFrame" given the type hint
    #   "pandera.typing.DataFrame[...]").
    hint_type = get_hint_pep484585_generic_type(
        hint=hint,
        exception_cls=BeartypeDecorHintNonpepPanderaException,
        exception_prefix=exception_prefix,
    )

    # Fully-qualified name of the module to be searched for.
    module_name = 'pandas'

    # Fully-qualified name of the module to be searched for suffixed by a "."
    # delimiter. This is a micro-optimization improving lookup speed.
    module_name_prefix = f'{module_name}.'

    # For each superclass of this unsubscripted generic type...
    for hint_base in hint_type.__mro__:
        # Fully-qualified name of the module declaring this superclass if any
        # *OR* "None" otherwise (i.e., if this type is only defined in-memory).
        hint_base_module_name = get_object_module_name_or_none(hint_base)

        # If this module exists *AND* either...
        if hint_base_module_name and (
            # This module is the desired module itself *OR*...
            hint_base_module_name == module_name_prefix or
            # This module is a submodule of the desired module...
            hint_base_module_name.startswith(module_name_prefix)
        # Then return this superclass.
        ):
            # print(f'Found generic {repr(hint)} type {repr(hint_type)} "{module_name}" superclass {repr(hint_base)}!')
            return hint_base
        # Else, this is *NOT* a Pandas module. In this case, continue to the
        # next superclass.
    # Else, *NO* superclass of this Pandera generic is a Pandas type.

    # Raise an exception.
    raise BeartypeDecorHintNonpepPanderaException(
        f'{exception_prefix}PEP 484 or 585 generic {repr(hint)} '
        f'type {repr(hint_type)} subclasses no "{module_name}" type '
        f'(i.e., type method resolution order (MRO) '
        f'{repr(hint_type.__mro__)} has no type with '
        f'module name prefixed by "{module_name}").'
    )
