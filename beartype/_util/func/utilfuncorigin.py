#!/usr/bin/env python3
# --------------------( LICENSE                           )--------------------
# Copyright (c) 2014-2021 Beartype authors.
# See "LICENSE" for further details.

'''
Project-wide **callable origin** (i.e., uncompiled source from which a compiled
callable originated) utilities.

This private submodule implements supplementary callable-specific utility
functions required by various :mod:`beartype` facilities, including callables
generated by the :func:`beartype.beartype` decorator.

This private submodule is *not* intended for importation by downstream callers.
'''

# ....................{ IMPORTS                           }....................
from ast import (
    NodeVisitor,
    parse as ast_parse,
)
from beartype.cave import CallableTypes
from beartype.roar import _BeartypeUtilCallableException
from beartype._util.func.utilfunccodeobj import (
    get_func_codeobj,
    get_func_unwrapped_codeobj_or_none,
)
from beartype._util.func.utilfunctest import (
    die_unless_func_lambda,
    die_unless_func_python,
)
from beartype._util.py.utilpyversion import IS_PYTHON_AT_LEAST_3_9
from collections.abc import Callable
from inspect import findsource, getsource
from sys import modules
from typing import List, Optional
from warnings import warn

# If the active Python interpreter targets Python >= 3.9 and thus defines the
# ast.unparse() function conditionally called below, import this function at
# module scope for efficiency.
if IS_PYTHON_AT_LEAST_3_9:
    from ast import unparse as ast_unparse  # type: ignore[attr-defined]

# See the "beartype.cave" submodule for further commentary.
__all__ = ['STAR_IMPORTS_CONSIDERED_HARMFUL']

# ....................{ CLASSES                           }....................
#FIXME: Docstring us up.
class _LambdaNodeUnparser(NodeVisitor):

    def __init__(self, lambda_lineno: int):

        super().__init__()

        if not IS_PYTHON_AT_LEAST_3_9:
            raise _BeartypeUtilCallableException(
                f'{repr(type(self))} only usable under Python >= 3.9.')

        self.lambdas_code: List[str] = []
        self._lambda_lineno = lambda_lineno

    def visit_Lambda(self, node):

        if node.lineno == self._lambda_lineno:
            try:
                self.lambdas_code.append(ast_unparse(node))
            # If the ast.unparse() function exhausts the stack due to recursion
            # overflow (*sigh*), reduce this fatal error to a non-fatal warning.
            #
            # Specifically, official documentation for ast.unparse() reads:
            #     Warning; Trying to unparse a highly complex expression would
            #     result with RecursionError.
            except RecursionError:
                #FIXME: Sanitize all warnings emitted in this submodule!
                warn('Ugh!')

        # Recursively visit all child nodes of this lambda node. While doing so
        # seems largely useless, a sufficient number of dragons are skulking
        # around here to warrant an abundance of caution and +1 Magic Swords.
        self.generic_visit(node)

# ....................{ GETTERS ~ code                    }....................
#FIXME: Improve with lambda-specific support. If the passed callable is a
#lambda, this getter erroneously returns the *ENTIRE* line containing that
#lambda rather than the substring of that line specifically declaring that
#lambda. Sadly, we can verify after several hours of online grepping that there
#is *NO* means of obtaining that substring *WITHOUT* importing one of the two
#following third-party packages:
#* "asttokens", as implemented by the third-party "icontract" package:
#  https://github.com/Parquery/icontract/blob/master/icontract/_represent.py
#* "astunparse", as implemented by this StackOverflow solution:
#  https://stackoverflow.com/a/64421174/2809027
#Since the StackOverflow solution is substantially simpler, "astunparse" would
#appear to be the solution here. We're certainly *NOT* requiring "astunparse"
#as a mandatory dependency, but optionally importing that package to display
#lambda code on exceptions (if installed) wouldn't necessarily be the worst
#decision we've ever made. *shrug*
#FIXME: Eureka! Python 3.9 now provides an ast.unparse() function trivially
#doing everything that "astunparse" does. Unsurprisingly, "astunparse" does
#*NOT* support Python 3.9. Ergo, it's dead. Ergo, we just want to call
#ast.unparse(). Since all of this is only meaningfully usable under Python >=
#3.9 anyway, this imposes no hardship whatsoever. The question then becomes:
#how exactly do we call ast.unparse()? We have no idea, but the solution
#probably resembles something like this:


#FIXME: Unit test us up.
#FIXME: Docstring us up.
#FIXME: Comment us up.
#FIXME: Contribute back to this StackOverflow question as a new answer, as this
#is highly non-trivial, frankly:
#    https://stackoverflow.com/questions/59498679/how-can-i-get-exactly-the-code-of-a-lambda-function-in-python/64421174#64421174
def get_func_lambda_origin_code_or_none(
    # Mandatory parameters.
    func: Callable,

    # Optional parameters.
    exception_cls: type = _BeartypeUtilCallableException,
) -> Optional[str]:

    #FIXME: Define us up, please.
    die_unless_func_lambda(func)

    if IS_PYTHON_AT_LEAST_3_9:
        lambda_origin_file_code = get_func_origin_file_code_or_none(
            func=func, exception_cls=exception_cls)

        if lambda_origin_file_code:
            func_codeobj = get_func_codeobj(func)

            ast_tree = ast_parse(lambda_origin_file_code)

            lambda_node_unparser = _LambdaNodeUnparser(
                lambda_lineno=func_codeobj.co_firstlineno)
            lambda_node_unparser.visit(ast_tree)
            lambdas_code = lambda_node_unparser.lambdas_code

            if not lambdas_code:
                raise exception_cls(
                    f'Lambda function {repr(func)} declared on '
                    f'line {func_codeobj.co_firstlineno} of '
                    f'file "{func_codeobj.co_filename}" not found.'
                )
            # If multiple
            elif len(lambdas_code) >= 2:
                warn('Ugh!')

            return lambdas_code[0]

    return get_func_origin_code_or_none(
        func=func, exception_cls=exception_cls)


#FIXME: Unit test us up.
def get_func_origin_code_or_none(
    # Mandatory parameters.
    func: Callable,

    # Optional parameters.
    exception_cls: type = _BeartypeUtilCallableException,
) -> Optional[str]:
    '''
    **Uncompiled Python source code** (i.e., string concatenating the subset of
    all lines of the on-disk Python script or module declaring the passed
    pure-Python callable) of that callable if that callable was declared
    on-disk *or* ``None`` otherwise (i.e., if that callable was dynamically
    declared in-memory).

    Caveats
    ----------
    **This getter is excruciatingly slow** and should thus be called *only*
    when unavoidable and ideally *only* in performance-agnostic code paths.
    Specifically, this getter finds the relevant lines by parsing the script or
    module declaring that callable beginning at the first line of that
    declaration and continuing until a rudimentary Python tokenizer implemented
    in pure-Python with *no* concern for optimization and thus slow beyond all
    understanding of "slow" detects the last line of that declaration. In
    theory, we could significantly optimize that process; in practice, anyone
    who cares should probably just compile or JIT :mod:`beartype` instead.

    Parameters
    ----------
    func : Union[Callable, CodeType, FrameType]
        Callable or frame or code object to be inspected.
    exception_cls : type, optional
        Type of exception in the event of a fatal error. Defaults to
        :class:`_BeartypeUtilCallableException`.

    Returns
    ----------
    Optional[str]
        Either:

        * If the passed callable was physically declared by an on-disk script
          or module, a string concatenating the subset of lines of that script
          or module declaring that callable.
        * If the passed callable was dynamically declared in-memory, ``None``.

    Raises
    ----------
    exception_cls
         If the passed callable is *not* pure-Python.
    '''

    # If the passed callable is *NOT* pure-Python, raise an exception.
    die_unless_func_python(func=func, exception_cls=exception_cls)
    # Else, the passed callable is pure-Python.

    # Attempt to defer to the standard inspect.getsource() function.
    try:
        return getsource(func)
    # If that function raised an "OSError" exception, that function failed to
    # find that callable (e.g., due to that callable being declared in-memory
    # rather than on-disk). In this case, return "None" instead.
    except OSError:
        return None


#FIXME: Unit test us up.
def get_func_origin_file_code_or_none(
    # Mandatory parameters.
    func: Callable,

    # Optional parameters.
    exception_cls: type = _BeartypeUtilCallableException,
) -> Optional[str]:
    '''
    **Uncompiled Python source file code** (i.e., string concatenating *all*
    lines of the on-disk Python script or module declaring the passed
    pure-Python callable) of that callable if that callable was declared
    on-disk *or* ``None`` otherwise (i.e., if that callable was dynamically
    declared in-memory).

    Caveats
    ----------
    **This getter is excruciatingly slow.** See
    :func:`get_func_origin_code_or_none` for further commentary.

    Parameters
    ----------
    func : Union[Callable, CodeType, FrameType]
        Callable or frame or code object to be inspected.
    exception_cls : type, optional
        Type of exception in the event of a fatal error. Defaults to
        :class:`_BeartypeUtilCallableException`.

    Returns
    ----------
    Optional[str]
        Either:

        * If the passed callable was physically declared by an on-disk script
          or module, a string concatenating *all* lines of that file.
        * If the passed callable was dynamically declared in-memory, ``None``.

    Raises
    ----------
    exception_cls
         If the passed callable is *not* pure-Python.
    '''

    # If the passed callable is *NOT* pure-Python, raise an exception.
    die_unless_func_python(func=func, exception_cls=exception_cls)
    # Else, the passed callable is pure-Python.

    # Attempt to defer to the standard inspect.findsource() function, which
    # returns a 2-tuple "(file_code_lines, file_code_lineno_start)", where:
    # * "file_code_lines" is a list of all lines of the script or module
    #    declaring the passed callable.
    # * "file_code_lineno_start" is the line number of the first such line
    #    declaring the passed callable. Since this line number is already
    #    provided by the "co_firstlineno" instance variable of this callable's
    #    code object, however, there is *NO* reason whatsoever to return this
    #    line number. Indeed, it's unclear why that function returns this
    #    redundant and thus useless metadata in the first place. *sigh*
    try:
        # List of all lines of the file declaring the passed callable.
        func_file_code_lines, _ = findsource(func)

        # Return this list concatenated into a string.
        return ''.join(func_file_code_lines)
    # If that function raised an "OSError" exception, that function failed to
    # find that callable (e.g., due to that callable being declared in-memory
    # rather than on-disk). In this case, return "None" instead.
    except OSError:
        return None

# ....................{ GETTERS ~ label                   }....................
def get_func_origin_label(func: Callable) -> str:
    '''
    Human-readable label describing the **origin** (i.e., uncompiled source) of
    the passed callable.

    Specifically, this getter returns either:

    * If that callable is pure-Python *and* physically declared on-disk, the
      absolute filename of the uncompiled on-disk Python script or module
      physically declaring that callable.
    * If that callable is pure-Python *and* dynamically declared in-memory,
      the placeholder string ``"<string>"``.
    * If that callable is C-based, the placeholder string ``"<C-based>"``.

    Caveats
    ----------
    **This getter is intentionally implemented for speed rather than robustness
    against unlikely edge cases.** The string returned by this getter is *only*
    intended to be embedded in human-readable labels, warnings, and exceptions.
    Avoid using this string for *any* mission-critical purpose.

    Parameters
    ----------
    func : Callable
        Callable to be inspected.

    Returns
    ----------
    str
        Either:

        * If that callable is physically declared by an uncompiled Python
          script or module, the absolute filename of this script or module.
        * Else, the placeholder string ``"<string>"`` implying that callable to
          have been dynamically declared in-memory.

    Raises
    ------
    _BeartypeUtilCallableException
        If that callable is *not* callable.

    See Also
    ----------
    :func:`inspect.getsourcefile`
        Inefficient stdlib function strongly inspiring this implementation,
        which has been highly optimized for use by the performance-sensitive
        :func:`beartype.beartype` decorator.
    '''

    # If this callable is uncallable, raise an exception.
    if not callable(func):
        raise _BeartypeUtilCallableException(f'{repr(func)} not callable.')
    # Else, this callable is callable.

    # Human-readable label describing the origin of the passed callable.
    func_origin_label = '<string>'

    # If this callable is a standard callable rather than arbitrary class or
    # object overriding the __call__() dunder method...
    if isinstance(func, CallableTypes):
        #FIXME: This is probably a bit overkill, as @beartype absolutely
        #*REQUIRES* pure-Python rather than C-based callables, as the latter
        #are *NOT* efficiently introspectable at runtime. *shrug*

        # Default this label to the placeholder string specific to C-based
        # callables to simplify subsequent logic.
        func_origin_label = '<C-based>'

        # Code object underlying the passed pure-Python callable unwrapped if
        # this callable is pure-Python *OR* "None" otherwise.
        #
        # Note that we intentionally do *NOT* test whether this callable is
        # explicitly pure-Python or C-based: e.g.,
        #     # If this callable is implemented in C, this callable has no code
        #     # object with which to inspect the filename declaring this callable. In
        #     # this case, defer to a C-specific placeholder string.
        #     if isinstance(func, CallableCTypes):
        #         func_origin_label = '<C-based>'
        #     # Else, this callable is implemented in Python. In this case...
        #     else:
        #         # If this callable is a bound method wrapping an unbound function,
        #         # unwrap this method into the function it wraps. Why? Because only
        #         # the latter provides the code object for this callable.
        #         if isinstance(func, MethodBoundInstanceOrClassType):
        #             func = func.__func__
        #
        #         # Defer to the absolute filename of the Python file declaring this
        #         # callable, dynamically retrieved from this callable's code object.
        #         func_origin_label = func.__code__.co_filename
        #
        # Why? Because PyPy. The logic above succeeds for CPython but fails for
        # PyPy, because *ALL CALLABLES ARE C-BASED IN PYPY.* Adopting the above
        # approach would unconditionally return the C-specific placeholder
        # string for all callables -- including those originally declared as
        # pure-Python in a Python module. So it goes.
        func_codeobj = get_func_unwrapped_codeobj_or_none(func)

        # If this callable has a code object, set this label to either the
        # absolute filename of the physical Python module or script declaring
        # this callable if this code object provides that metadata *OR* the
        # current placeholder string otherwise.
        #
        # Note that we intentionally do *NOT* assume all code objects to
        # provide this metadata (e.g., by unconditionally returning
        # "func_origin_label = func_codeobj.co_filename"). Why? Because PyPy
        # yet again. For inexplicable reasons, PyPy provides *ALL* C-based
        # builtins (e.g., len()) with code objects failing to provide this
        # metadata. Yes, this is awful. Yes, this is the Python ecosystem.
        if func_codeobj:
            func_origin_label = getattr(
                func_codeobj, 'co_filename', func_origin_label)
    # Else, this callable is *NOT* a standard callable. In this case...
    else:
        # If this callable is *NOT* a class (i.e., is an object defining the
        # __call__() method), reduce this callable to the class of this object.
        if not isinstance(func, type):
            func = type(func)
        # In either case, this callable is now a class.

        # Fully-qualified name of the module declaring this class if this class
        # was physically declared by an on-disk module *OR* "None" otherwise.
        func_module_name = func.__module__

        # If this class was physically declared by an on-disk module, defer to
        # the absolute filename of that module.
        #
        # Note that arbitrary modules need *NOT* declare the "__file__" dunder
        # attribute. Unlike most other core Python objects, modules are simply
        # arbitrary objects that reside in the "sys.modules" dictionary.
        if func_module_name:
            func_origin_label = getattr(
                modules[func_module_name], '__file__', func_origin_label)

    # Return this label.
    return func_origin_label
