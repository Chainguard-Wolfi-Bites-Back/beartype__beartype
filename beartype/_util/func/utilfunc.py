#!/usr/bin/env python3
# --------------------( LICENSE                           )--------------------
# Copyright (c) 2014-2021 Cecil Curry.
# See "LICENSE" for further details.

'''
**Beartype callable utilities.**

This private submodule implements supplementary callable-specific utility
functions required by various :mod:`beartype` facilities, including callables
generated by the :func:`beartype.beartype` decorator.

This private submodule is *not* intended for importation by downstream callers.
'''

# ....................{ TODO                              }....................
#FIXME: Generalize get_callable_filename_or_placeholder() to support PyPy.
#Although PyPy clearly is internally reducing pure-Python callables into
#C-based callables, it *SHOULD* also be preserving their code objects for
#subsequent inspection. This means that the "if isinstance(func,
#CallableCTypes):" test is insufficient. We should probably instead be more
#generally testing whether the passed callable has a "__code__" attribute
#defined. Oh, PyPy. This is why good things are hard to acquire.

# ....................{ IMPORTS                           }....................
from collections.abc import Callable
from sys import modules
from beartype.cave import CallableCTypes, MethodBoundInstanceOrClassType
from beartype.roar import _BeartypeUtilCallableException

# ....................{ GETTERS                           }....................
def get_callable_filename_or_placeholder(func: Callable) -> str:
    '''
    Absolute filename of the uncompiled Python script or module physically
    declaring the passed callable if any *or* the placeholder string
    ``"<string>"`` implying this callable to have been dynamically declared
    in-memory otherwise.

    Parameters
    ----------
    func : Callable
        Callable to be inspected.

    Returns
    ----------
    str
        Either:

        * If this callable is physically declared by an uncompiled Python
          script or module, the absolute filename of this script or module.
        * Else, the placeholder string ``"<string>"`` implying this callable to
          have been dynamically declared in-memory.

    See Also
    ----------
    :func:`inspect.getsourcefile`
        Inefficient stdlib function strongly inspiring this implementation,
        which has been highly optimized for use by the performance-sensitive
        :func:`beartype.beartype` decorator.
    '''

    # If this callable is *NOT*, raise an exception.
    if not callable(func):
        raise _BeartypeUtilCallableException(f'{repr(func)} not callable.')

    # Absolute filename of this callable if this callable was physically
    # declared by an on-disk file *OR* a default placeholder otherwise. For
    # simplicity, initialize this filename to that placeholder.
    filename = '<string>'

    # If this callable is a callable class defining the __call__() method...
    if isinstance(func, type):
        # Fully-qualified name of the module declaring this class if this class
        # was physically declared by an on-disk module *OR* "None" otherwise.
        func_module_name = func.__module__

        # If this class was physically declared by an on-disk module, defer to
        # the absolute filename of that module.
        #
        # Note that arbitrary modules need *NOT* declare the "__file__" dunder
        # attribute. Unlike most other core Python objects, modules are simply
        # arbitrary objects that reside in the "sys.modules" dictionary.
        if func_module_name:
            filename = getattr(modules[func_module_name], '__file__', filename)
    # Else, this callable is *NOT* a callable class. In this case, this
    # callable *MUST* be either...
    else:
        # If this callable is implemented in C, this callable has no code
        # object with which to inspect the filename declaring this callable. In
        # this case, defer to a C-specific placeholder string.
        if isinstance(func, CallableCTypes):
            filename = '<C-based>'
        # Else, this callable is implemented in Python. In this case...
        else:
            # If this callable is a bound method wrapping an unbound function,
            # unwrap this method into the function it wraps. Why? Because only
            # the latter provides the code object for this callable.
            if isinstance(func, MethodBoundInstanceOrClassType):
                func = func.__func__

            # Defer to the absolute filename of the Python file declaring this
            # callable, dynamically retrieved from this callable's code object.
            filename = func.__code__.co_filename

    # Return this filename.
    return filename
