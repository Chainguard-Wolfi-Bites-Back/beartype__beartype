#!/usr/bin/env python3
# --------------------( LICENSE                            )--------------------
# Copyright (c) 2014-2023 Beartype authors.
# See "LICENSE" for further details.

'''
Beartype :pep:`695`-compliant **abstract syntax tree (AST) transformers** (i.e.,
low-level classes instrumenting :pep:`695`-compliant ``type`` alias statements
in well-typed third-party modules with runtime type-checking dynamically
generated by the :func:`beartype.beartype` decorator).

This private submodule is *not* intended for importation by downstream callers.
'''

# ....................{ TODO                               }....................
#FIXME: CPython's current implementation of PEP 695 type aliases is
#fundamentally broken with respect to unquoted relative forward references.
#Please submit an upstream issue describing this patent failure. On doing so,
#please also publicly declare that PEP 695 appears to have been poorly tested.
#As evidence, note that PEP 695 itself advises use of the following idiom:
#    # A type alias that includes a forward reference
#    type AnimalOrVegetable = Animal | "Vegetable"
#
#*THAT DOES NOT ACTUALLY WORK AT RUNTIME.* Nobody tested that. This is why I
#facepalm. Notably, PEP 604-compliant new-style unions prohibit strings. They
#probably shouldn't, but they've *ALWAYS* behaved that way, and nobody's updated
#them to behave more intelligently -- probably because doing so would require
#updating the isinstance() builtin (which also accepts PEP 604-compliant
#new-style unions) to behave more intelligently and ain't nobody goin' there:
#    $ python3.12
#    >>> type AnimalOrVegetable = "Animal" | "Vegetable"
#    >>> AnimalOrVegetable.__value__
#    Traceback (most recent call last):
#      Cell In[3], line 1
#        AnimalOrVegetable.__value__
#      Cell In[2], line 1 in AnimalOrVegetable
#        type AnimalOrVegetable = "Animal" | "Vegetable"
#    TypeError: unsupported operand type(s) for |: 'str' and 'str'
#
#However, even ignoring that obvious syntactic issue, PEP 695 still fails to
#actually support forward references -- because exceptions are *NOT* forward
#references. Forward references are proxy objects that refer to other objects
#that have yet to be defined at runtime. Notably, this is bad:
#    $ python3.12
#    >>> type AnimalOrAnimals = Animal | list[Animal]
#    >>> AnimalOrAnimals.__value__
#    Traceback (most recent call last):
#      Cell In[2], line 1
#        AnimalOrAnimals.__value__
#      Cell In[1], line 1 in AnimalOrAnimals
#        type AnimalOrAnimals = Animal | list[Animal]
#    NameError: name 'Animal' is not defined
#
#*FACEPALM*

# ....................{ IMPORTS                            }....................
# from ast import (
#     TypeAlias,
# )
from beartype.claw._clawmagic import (
    NODE_CONTEXT_LOAD,
)
from beartype.claw._clawtyping import NodeVisitResult
from beartype._util.ast.utilastmunge import copy_node_metadata

# ....................{ SUBCLASSES                         }....................
#!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
# CAUTION: To improve forward compatibility with the superclass API over which
# we have *NO* control, avoid accidental conflicts by suffixing *ALL* private
# and public attributes of this subclass by "_beartype".
#!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

class BeartypeNodeTransformerPep695Mixin(object):
    '''
    Beartype :pep:`695`-compliant **abstract syntax tree (AST) node
    transformer** (i.e., visitor pattern recursively transforming *all*
    :pep:`695`-compliant ``type`` alias statements in the AST tree passed to the
    :meth:`visit` method of the
    :class:`beartype.claw._ast.clawastmain.BeartypeNodeTransformer` subclass
    also subclassing this mixin).
    '''

    # ..................{ VISITORS ~ pep : 695               }..................
    def visit_TypeAlias(self, node: 'ast.TypeAlias') -> NodeVisitResult:  # type: ignore[name-defined]
        '''
        Add new sibling nodes following the passed **type alias statement**
        (i.e., node signifying the definition of a :pep:`695`-compliant ``type``
        alias) iteratively defining one **forward reference proxy** (i.e.,
        :class:`beartype._check.forward.fwdtype.BeartypeForwardRefABC` subclass)
        for each unquoted relative forward reference in this statement.

        Doing so is required, as :pep:`695` fails to actually support unquoted
        relative forward references despite publicly claiming to do so. Notably,
        :pep:`695`-compliant type aliases raise non-human-readable
        :exc:`NameError` and :exc:`UnboundLocalError` exceptions when attempting
        to resolve type aliases containing one or more unquoted relative forward
        references. Clearly, exceptions are *not* valid forward references.
        Forward references are proxy objects that refer to other objects that
        have yet to be defined at runtime. Notably, this is very awful:

        .. code-block:: pycon

        >>> type AnimalOrAnimals = Animal | list[Animal]
        >>> AnimalOrAnimals.__value__
        Traceback (most recent call last):
          Cell In[2], line 1
            AnimalOrAnimals.__value__
          Cell In[1], line 1 in AnimalOrAnimals
            type AnimalOrAnimals = Animal | list[Animal]
        NameError: name 'Animal' is not defined

        Circumventing this patent oversight on the part of both Guido and PEP
        695 authors requires transforming this AST to inject new sibling nodes
        encapsulating each unquoted relative forward reference in this alias
        with a new forward reference proxy and then redefining this alias to
        forcefully uncache this alias.

        Parameters
        ----------
        node : TypeAlias
            Type alias to be transformed.

        Returns
        -------
        NodeVisitResult
            A list comprising (in order):

            #. This type alias node as is.
            #. New sibling nodes encapsulating each unquoted relative forward
               reference in this alias with a new forward reference proxy.
            #. This type alias node recapitulated to undo any prior caching of
               this type alias.
        '''

        # Recursively transform *ALL* child nodes of this type alias node.
        self.generic_visit(node)  # type: ignore[attr-defined]

        # Copy all source code metadata from this type alias node onto *ALL*
        # sibling nodes created above.
        # copy_node_metadata(node_src=node, node_trg=(
        #     node_func,
        # ))

        # Return a list comprising these adjacent nodes.
        #
        # Note that order is *EXTREMELY* significant.
        return [
            node,
        ]
