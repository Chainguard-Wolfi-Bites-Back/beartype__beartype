#!/usr/bin/env python3
# --------------------( LICENSE                            )--------------------
# Copyright (c) 2014-2023 Beartype authors.
# See "LICENSE" for further details.

'''
**Beartype all-at-once low-level abstract syntax tree (AST) transformation.**

This private submodule defines the low-level abstract syntax tree (AST)
transformation automatically decorating well-typed third-party packages and
modules with runtime type-checking dynamically generated by the
:func:`beartype.beartype` decorator.

This private submodule is *not* intended for importation by downstream callers.
'''

# ....................{ TODO                               }....................
#FIXME: Additionally define a new BeartypeNodeTransformer.visit_ClassDef()
#method modelled after the equivalent TypeguardTransformer.visit_ClassDef()
#method residing at:
#    https://github.com/agronholm/typeguard/blob/master/src/typeguard/importhook.py

#FIXME: *OMG.* See also the third-party "executing" Python package:
#    https://github.com/alexmojaki/executing
#
#IPython itself internally leverages "executing" via "stack_data" (i.e., a
#slightly higher-level third-party Python package that internally leverages
#"executing") to syntax-highlight the currently executing AST node. Indeed,
#"executing" sports an intense test suite (much like ours) effectively
#guaranteeing a one-to-one mapping between stack frames and AST nodes.
#
#So, what's the Big Idea here? The Big Idea here is that @beartype can
#internally (...possibly only optionally, but possibly mandatorily) leverage
#"executing" to begin performing full-blown static type-checking at runtime --
#especially of mission critical type hints like "typing.LiteralString" which can
#*ONLY* be type-checked via static analysis. :o
#
#So, what's the Little Idea here? The Little Idea here is that @beartype can
#generate type-checking wrappers that type-check parameters or returns annotated
#by "typing.LiteralString" by calling an internal private utility function --
#say, "_die_unless_literalstring(func: Callable, arg_name: str) -> None" -- with
#"func" as the current type-checking wrapper and "arg_name" as either the name
#of that parameter or "return". The _die_unless_literalstring() raiser then:
#* Dynamically searches up the call stack for the stack frame encapsulating an
#  external call to the passed "func" callable.
#* Passes that stack frame to the "executing" package.
#* "executing" then returns the AST node corresponding to that stack frame.
#* Introspects that node for the passed parameter whose name is "arg_name".
#* Raises an exception unless the value of that parameter is an AST node
#  corresponding to a string literal.
#
#Of course, that won't necessarily be fast -- but it will be accurate. Since
#security trumps speed, speed is significantly less of a concern insofar as
#"typing.LiteralString" is concerned. Of course, we should also employ
#significant caching... if we even can.
#FIXME: Actually, while demonstrably awesome, even the above fails to suffice to
#to statically type-check "typing.LiteralString". We failed to fully read PEP
#675, which contains a section on inference. In the worst case, nothing less
#than a complete graph of the entire app and all transitive dependencies thereof
#suffices to decide whether a parameter satisfies "typing.LiteralString".
#
#Thankfully, the above idea generalizes from "typing.LiteralString" to other
#fascinating topics as well. Indeed, given sufficient caching, one could begin
#to internally generate and cache a mypy-like graph network whose nodes are
#typed attributes and whose edges are relations between those typed attributes.

# ....................{ IMPORTS                            }....................
from ast import (
    AST,
    AnnAssign,
    Call,
    Expr,
    FunctionDef,
    ImportFrom,
    Load,
    Module,
    Name,
    NodeTransformer,
    Str,
    alias,
)
from beartype.typing import (
    List,
    Union,
)
from beartype._conf.confcls import BeartypeConf
from beartype._util.py.utilpyversion import IS_PYTHON_AT_LEAST_3_8

# ....................{ SUBCLASSES                         }....................
#!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
# CAUTION: To improve forward compatibility with the superclass API over which
# we have *NO* control, avoid accidental conflicts by suffixing *ALL* private
# and public attributes of this subclass by "_beartype".
#!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

#FIXME: Unit test us up, please.
class BeartypeNodeTransformer(NodeTransformer):
    '''
    **Beartype abstract syntax tree (AST) node transformer** (i.e., visitor
    pattern recursively transforming the AST tree passed to the :meth:`visit`
    method by decorating all typed callables and classes by the
    :func:`beartype.beartype` decorator).

    Attributes
    ----------
    _conf_beartype : BeartypeConf
        Either:

        * If the most recent call to the :meth:`get_code` method loading a
          module (i.e., creating and return the code object underlying that
          module) was passed the fully-qualified name of a module with a
          transitive parent package previously registered by a call to a public
          :mod:`beartype.claw` import hook factory (e.g.,
          :func:`beartype.claw.beartype_package`), the beartype configuration
          with which to type-check that module.
        * Else, :data:`None`.

    See Also
    ----------
    * The `comparable "typeguard.importhook" submodule <typeguard import
      hook_>`__ implemented by the incomparable `@agronholm (Alex Gr√∂nholm)
      <agronholm_>`__.

    .. _agronholm:
       https://github.com/agronholm
    .. _typeguard import hook:
       https://github.com/agronholm/typeguard/blob/master/src/typeguard/importhook.py
    '''

    # ..................{ VISITORS ~ module                  }..................
    def visit_Module(self, node: Module) -> Module:
        '''
        Add a new abstract syntax tree (AST) child node to the passed AST module
        parent node encapsulating the module currently being loaded by the
        :class:`beartype.claw._clawloader.BeartypeSourceFileLoader` object,
        importing our private
        :func:`beartype._decor.decorcore.beartype_object_nonfatal` decorator for
        subsequent use by the other visitor methods defined by this class.

        Parameters
        ----------
        node : Module
            AST module parent node to be transformed.

        Returns
        ----------
        Module
            That same AST module parent node.
        '''

        # 0-based index of the first safe position in the list of all child
        # nodes of this parent module node to insert an import statement
        # importing our beartype decorator, initialized to the erroneous index
        # "-1" to enable detection of empty modules (i.e., modules whose module
        # nodes containing *NO* child nodes) below.
        node_import_beartype_attrs_index = -1

        # Child node of this parent module node immediately preceding the output
        # import child node to be added below, defaulting to this parent module
        # node to ensure that the _copy_node_code_metadata() function below
        # *ALWAYS* copies from a valid node (for simplicity).
        node_import_prev: AST = node

        # For the 0-based index and value of each direct child node of this
        # parent module node...
        #
        # This iteration efficiently finds "node_import_beartype_attrs_index"
        # (i.e., the 0-based index of the first safe position in the list of all
        # child nodes of this parent module node to insert an import statement
        # importing our beartype decorator). Despite superficially appearing to
        # perform a linear search of all n child nodes of this module parent
        # node and thus exhibit worst-case O(n) time complexity, this iteration
        # is guaranteed to exhibit worst-case O(1) time complexity. \o/
        #
        # Note that the "body" instance variable for module nodes is a list of
        # all child nodes of this parent module node.
        for node_import_beartype_attrs_index, node_import_prev in enumerate(
            node.body):
            # If it is *NOT* the case that this child node signifies either...
            if not (
                # A module docstring...
                #
                # If that module defines a docstring, that docstring *MUST* be
                # the first expression of that module. That docstring *MUST* be
                # explicitly found and iterated past to ensure that the import
                # statement added below appears *AFTER* rather than *BEFORE* any
                # docstring. (The latter would destroy the semantics of that
                # docstring by reducing that docstring to an ignorable string.)
                (
                    isinstance(node_import_prev, Expr) and
                    isinstance(node_import_prev.value, Str)
                ) or
                # A future import (i.e., import of the form "from __future__
                # ...") *OR*...
                #
                # If that module performs one or more future imports, these
                # imports *MUST* necessarily be the first non-docstring
                # statement of that module and thus appear *BEFORE* all import
                # statements that are actually imports -- including the import
                # statement added below.
                (
                    isinstance(node_import_prev, ImportFrom) and
                    node_import_prev.module == '__future__'
                )
            # Then immediately halt iteration, guaranteeing O(1) runtime.
            ):
                break
            # Else, this child node signifies either a module docstring of
            # future import. In this case, implicitly skip past this child node
            # to the next child node.
            #
        # "node_import_beartype_attrs_index" is now the index of the first safe
        # position in this list to insert output child import nodes below.

        # If this is *NOT* the erroneous index to which this index was
        # initialized above, this module contains one or more child nodes and is
        # thus non-empty. In this case...
        if node_import_beartype_attrs_index >= 0:
            # Module-scoped import nodes (i.e., child nodes to be inserted under
            # the parent node encapsulating the currently visited submodule in
            # the AST for that module).
            #
            # Note that these nodes are intentionally *NOT* generalized into
            # global constants. In theory, doing so would reduce space and time
            # complexity by enabling efficient reuse here. In practice, doing so
            # would also be fundamentally wrong; these nodes are subsequently
            # modified to respect the source code metadata (e.g., line numbers)
            # of this AST module parent node, which prevents such trivial reuse.
            # Although we could further attempt to circumvent that by shallowly
            # or deeply copying from global constants, both the copy() and
            # deepcopy() functions defined by the standard "copy" module are
            # pure-Python and thus shockingly slow -- which defeats the purpose.

            # Our private beartype._decor.decorcore.beartype_object_nonfatal()
            # decorator.
            node_import_decorator = ImportFrom(
                module='beartype._decor.decorcore',
                names=[alias('beartype_object_nonfatal')],
            )

            # Our public beartype.door.die_if_unbearable() raiser, intentionally
            # imported from our private "beartype.door._doorcheck" submodule
            # rather than our public "beartype.door" subpackage. Why? Because
            # the former consumes marginally less space and time to import than
            # the latter. Whereas the latter imports the full "TypeHint"
            # hierarchy, the former only imports low-level utility functions.
            node_import_raiser = ImportFrom(
                module='beartype.door._doorcheck',
                names=[alias('die_if_unbearable')],
            )

            # Copy all source code metadata (e.g., line numbers) from:
            # * For the first output import child node (in arbitrary order, as
            #   import statements are necessarily idempotent), from the input
            #   child node of this parent module node directly preceding this
            #   output node onto this output node.
            # * For all subsequent output import child nodes, from the preceding
            #   output node onto the current output node.
            _copy_node_code_metadata(
                node_src=node_import_prev, node_trg=node_import_decorator)
            _copy_node_code_metadata(
                node_src=node_import_prev, node_trg=node_import_raiser)

            # Insert these output import child nodes at this safe position of
            # the list of all child nodes of this parent module node.
            #
            # Note that this syntax efficiently (albeit unreadably) inserts
            # these output import child nodes at the desired index (in this
            # arbitrary order) of this parent module node.
            node.body[node_import_beartype_attrs_index:0] = (
                node_import_decorator, node_import_raiser)
        # Else, this module is empty. In this case, silently reduce to a noop.
        # Since this edge case is *EXTREMELY* uncommon, avoid optimizing for
        # this edge case (here or elsewhere).

        # Recursively transform *ALL* AST child nodes of this AST module node.
        self.generic_visit(node)

        # Return this AST module node as is.
        return node

    # ..................{ VISITORS ~ callable                }..................
    def visit_FunctionDef(self, node: FunctionDef) -> FunctionDef:
        '''
        Add a new abstract syntax tree (AST) child node to the passed AST
        callable parent node, decorating that callable by our private
        :func:`beartype._decor.decorcore.beartype_object_nonfatal` decorator if
        and only if that callable is **typed** (i.e., annotated by a return type
        hint and/or one or more parameter type hints).

        Parameters
        ----------
        node : FunctionDef
            AST callable parent node to be transformed.

        Returns
        ----------
        FunctionDef
            That same AST callable parent node.
        '''

        # True only if that callable is ignorable (i.e., annotated by *NO* type
        # hints), defaulting to whether that callable is annotated by a return
        # type hint.
        #
        # Note that this boolean is intentionally defining in an unintuitive
        # order so as to increase the likelihood of defining this boolean in
        # O(1) time. Specifically:
        # * It is most efficient to test whether that callable is annotated by a
        #   return type hint.
        # * It is next-most efficient to test whether that callable accepts a
        #   variadic positional argument annotated by a type hint.
        # * It is least efficient to test whether that callable accepts a
        #   non-variadic argument annotated by a type hint, as doing so requires
        #   O(n) iteration for "n" the number of such arguments..
        #
        # Lastly, note that we could naively avoid doing this entirely and
        # instead unconditionally decorate *ALL* callables by @beartype -- in
        # which case @beartype would simply reduce to a noop for ignorable
        # callables annotated by *NO* type hints. Technically, that works.
        # Pragmatically, that would almost certainly be slower than the current
        # approach under the common assumption that any developer annotating one
        # or more non-variadic arguments of a callable would also annotate the
        # return of that callable -- in which case this detection reduces to
        # O(1) time complexity. Even where this is *NOT* the case, however, this
        # is still almost certainly slightly faster or of an equivalent speed to
        # the naive approach. Why? Because treating ignorable callables as
        # unignorable would needlessly:
        # * Increase space complexity by polluting this AST with needlessly many
        #   "Name" child nodes performing ignorable @beartype decorations.
        # * Increase time complexity by instantiating, initializing, and
        #   inserting (the three dread i's) those nodes.
        is_ignorable = node.returns is None

        # If that callable is possibly ignorable...
        if is_ignorable:
            # Child arguments node of all arguments accepted by that callable.
            node_args = node.args

            # Variadic positional argument accepted by that callable if any.
            #
            # Note that @beartype currently prohibits type hints annotating
            # variadic keyword arguments, since there currently appears to be no
            # use case encouraging @beartype to support that.
            node_arg_varpos = node_args.vararg

            # If that callable accepts a variadic positional argument...
            if node_arg_varpos:
                # That callable is unignorable if that argument is annotated by
                # a type hint.
                is_ignorable = node_arg_varpos.annotation is None
            # Else, that callable accepts *NO* variadic positional argument.

            # If that callable is still possibly ignorable, fallback to deciding
            # whether that callable accepts one or more non-variadic arguments
            # annotated by type hints. Since doing is considerably more
            # computationally expensive, we do so *ONLY* as needed.
            #
            # Note that manual iteration is considerably more efficient than
            # more syntactically concise any() and all() generator expressions.
            if is_ignorable:
                for node_arg_nonvar in node_args.args:
                    if node_arg_nonvar.annotation is not None:
                        is_ignorable = False
                        break
            # Else, that callable is now unignorable.
        # Else, that callable is now unignorable.

        # If that callable is unignorable (i.e., annotated by type hints)...
        if not is_ignorable:
            #FIXME: Additionally pass the current beartype configuration as a
            #keyword-only "conf={conf}" parameter to this decorator, please.
            #Thankfully, this class is only instantiated in a single location in
            #the "_clawloader" submodule. Altogether, we'll need to refactor:
            #* The BeartypeNodeTransformer.__init__() method to accept a new
            #  "conf_beartype=BeartypeConf" parameter, which should be localized
            #  as a new "_conf_beartype" instance variable (for safety).
            #* The BeartypeSourceFileLoader.source_to_code() method in the
            #  "_clawloader" submodule to instantiate:
            #      ast_beartyper = BeartypeNodeTransformer(
            #          conf_beartype=self._module_conf_if_added)
            #FIXME: We're not done, however. Ideally, we should generalize the
            #BeartypeNodeTransformer.__new__() class method to internally cache
            #and return "BeartypeNodeTransformer" instances depending on the
            #passed "conf_beartype" parameter. In general, most codebases will
            #only leverage a single @beartype configuration (if any @beartype
            #configuration at all); ergo, caching improves everything by
            #enabling us to reuse the same "BeartypeNodeTransformer" instance
            #for every hooked module. Score @beartype!
            #
            #See the BeartypeConf.__new__() method for relevant logic. \o/

            #FIXME: Can the child 
            # AST decoration child node decorating that callable by our
            # beartype._decor.decorcore.beartype_object_nonfatal() decorator.
            #
            # Note that this syntax derives from the example for the ast.arg()
            # class:
            #     https://docs.python.org/3/library/ast.html#ast.arg
            decorate_callable = Name(
                id='beartype_object_nonfatal', ctx=_NODE_CONTEXT_LOAD)

            # Copy all source code metadata from this AST callable parent node
            # onto this AST decoration child node.
            _copy_node_code_metadata(node_src=node, node_trg=decorate_callable)

            # Prepend this child decoration node to the beginning of the list of
            # all child decoration nodes for this parent callable node. Since
            # this list is "stored outermost first (i.e. the first in the list
            # will be applied last)", prepending guarantees that our decorator
            # will be applied last (i.e., *AFTER* all subsequent decorators).
            # This ensures that explicitly configured @beartype decorations
            # (e.g., "beartype(conf=BeartypeConf(...))") assume precedence over
            # implicitly configured @beartype decorations inserted by this hook.
            node.decorator_list.insert(0, decorate_callable)
        # Else, that callable is ignorable. In this case, avoid needlessly
        # decorating that callable by @beartype for efficiency.

        # Recursively transform *ALL* AST child nodes of this AST callable node.
        self.generic_visit(node)

        # Return this AST callable node as is.
        return node

    # ..................{ VISITORS ~ pep 562                 }..................
    def visit_AnnAssign(self, node: AnnAssign) -> Union[AST, List[AST]]:
        '''
        Add a new abstract syntax tree (AST) child node to the passed AST
        **annotated assignment** (i.e., assignment of an attribute annotated by
        a :pep:`562`-compliant type hint) parent node, inserting a subsequent
        statement following that annotated assignment that type-checks that
        attribute against that type hint by passing both to our public
        :func:`beartype.door.is_bearable` tester.

        Parameters
        ----------
        node : AnnAssign
            AST annotated assignment parent node to be transformed.

        Returns
        ----------
        Union[AST, List[AST]]
            Either:

            * If this annotated assignment parent node is *not* **simple**
              (i.e., the attribute being assigned to is embedded in parentheses
              and thus denotes a full-blown Python expression rather than a
              simple attribute name), that same parent node unmodified.
            * Else, a 2-list comprising both that parent node and a new adjacent
              :class:`Call` node performing this type-check.

        See Also
        ----------
        https://github.com/awf/awfutils
            Third-party Python package whose ``@awfutils.typecheck`` decorator
            implements statement-level :func:`isinstance`-based type-checking in
            a similar manner, strongly inspiring this implementation. Thanks so
            much to Cambridge researcher @awf (Andrew Fitzgibbon) for the
            phenomenal inspiration!
        '''

        # Note that "AnnAssign" node subclass defines these instance variables:
        # * "node.annotation", a child node describing the PEP-compliant type
        #   hint annotating this assignment, typically an instance of either:
        #   * "ast.Name".
        #   * "ast.Str".
        # * "node.simple", a boolean that is true only if "node.target" is an
        #   "ast.Name" node.
        # * "node.target", a child node describing the target attribute assigned
        #   to by this assignment, guaranteed to be an instance of either:
        #   * "ast.Name", in which case this assignment is denoted as "simple"
        #     via the "node.simple" instance variable. This is the common case
        #     in which the attribute being assigned to is *NOT* embedded in
        #     parentheses and thus denotes a simple attribute name rather than a
        #     full-blown Python expression.
        #   * "ast.Attribute".
        #   * "ast.Subscript".
        # * "node.value", an optional child node describing the source value
        #   being assigned to this target attribute.

        #FIXME: Can and/or should we also support "node.target" child nodes that
        #are instances of "ast.Attribute" and "ast.Subscript"?
        # If this assignment is *NOT* simple, this assignment is *NOT* assigning
        # to an attribute name. In this case, silently ignore this assignment.
        if not node.simple:
            return node
        # Else, this assignment is simple and assigning to an attribute name.

        # Validate this fact.
        assert isinstance(node.target, Name)

        #FIXME: Additionally pass the current beartype configuration as a
        #keyword-only "conf={conf}" parameter to this raiser, please.

        # Child node referencing the function performing this type-checking,
        # previously imported at module scope by visit_FunctionDef() above.
        node_typecheck_function = Name(
            'die_if_unbearable', ctx=_NODE_CONTEXT_LOAD)

        # Child node passing the value newly assigned to this attribute by this
        # assignment as the first parameter to die_if_unbearable().
        node_typecheck_pith = Name(node.target.id, ctx=_NODE_CONTEXT_LOAD)

        # Adjacent node type-checking this newly assigned attribute against the
        # PEP-compliant type hint annotating this assignment by deferring to our
        # die_if_unbearable() raiser.
        node_typecheck = Call(
            node_typecheck_function,
            [
                # Child node passing the value newly assigned to this
                # attribute by this assignment as the first parameter.
                node_typecheck_pith,
                # Child node passing the type hint annotating this assignment as
                # the second parameter.
                node.annotation,
            ],
            [],
        )

        # Copy all source code metadata from this AST annotated assignment node
        # onto *ALL* AST nodes created above.
        _copy_node_code_metadata(
            node_src=node, node_trg=node_typecheck_function)
        _copy_node_code_metadata(node_src=node, node_trg=node_typecheck_pith)
        _copy_node_code_metadata(node_src=node, node_trg=node_typecheck)

        #FIXME: Can we replace this inefficient list with an efficient tuple?
        #Probably not. Let's avoid doing so for the moment, as the "ast" API is
        #obstruse enough as it is.
        # Return a list comprising these two adjacent nodes.
        return [node, node_typecheck]

# ....................{ PRIVATE ~ constants                }....................
_NODE_CONTEXT_LOAD = Load()
'''
**Node context load singleton** (i.e., object suitable for passing as the
``ctx`` keyword parameter accepted by the ``__init__()`` method of various
abstract syntax tree (AST) node classes).
'''

# ....................{ PRIVATE ~ copiers                  }....................
def _copy_node_code_metadata(node_src: AST, node_trg: AST) -> None:
    '''
    Copy all **source code metadata** (i.e., beginning and ending line and
    column numbers) from the passed source abstract syntax tree (AST) node onto
    the passed target AST node.

    This function is an efficient alternative to:

    * The extremely inefficient (albeit still useful)
      :func:`ast.fix_missing_locations` function.
    * The mildly inefficient (and mostly useless) :func:`ast.copy_location`
      function.

    The tradeoffs are as follows:

    * :func:`ast.fix_missing_locations` is ``O(n)`` time complexity for ``n``
      the number of AST nodes across the entire AST tree, but requires only a
      single trivial call and is thus considerably more "plug-and-play" than
      this function.
    * This function is ``O(1)`` time complexity irrespective of the size of the
      AST tree, but requires one still mostly trivial call for each synthetic
      AST node inserted into the AST tree by the
      :class:`BeartypeNodeTransformer` above.

    Parameters
    ----------
    node_src: AST
        Source AST node to copy source code metadata from.
    node_trg: AST
        Target AST node to copy source code metadata onto.

    See Also
    ----------
    :func:`ast.copy_location`
        Less efficient analogue of this function running in ``O(k)`` time
        complexity for ``k`` the number of types of source code metadata.
        Typically, ``k == 4``.
    '''
    assert isinstance(node_src, AST), f'{repr(node_src)} not AST node.'
    assert isinstance(node_trg, AST), f'{repr(node_trg)} not AST node.'

    # Copy all source code metadata from this source to target AST node.
    node_trg.lineno     = node_src.lineno
    node_trg.col_offset = node_src.col_offset

    # If the active Python interpreter targets Python >= 3.8, then additionally
    # copy all source code metadata exposed by Python >= 3.8.
    if IS_PYTHON_AT_LEAST_3_8:
        node_trg.end_lineno     = node_src.end_lineno  # type: ignore[attr-defined]
        node_trg.end_col_offset = node_src.end_col_offset  # type: ignore[attr-defined]
