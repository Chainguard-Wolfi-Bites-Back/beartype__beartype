#!/usr/bin/env python3
# --------------------( LICENSE                           )--------------------
# Copyright (c) 2014-2020 Cecil Curry.
# See "LICENSE" for further details.

'''
**Beartypistry** (i.e., singleton dictionary mapping from the fully-qualified
classnames of all type hints annotating callables decorated by the
:func:`beartype.beartype` decorator to those types).**

This private submodule is *not* intended for importation by downstream callers.
'''

# ....................{ IMPORTS                           }....................
from beartype.roar import (
    _BeartypeDecorBeartypistryException,
    _BeartypeCallBeartypistryException,
)
from beartype._util.utilobject import get_object_name_qualified
from beartype._util.hint.utilhint import die_unless_hint
from beartype._util.hint.pep.utilhintpeptest import is_hint_pep

# See the "beartype.__init__" submodule for further commentary.
__all__ = ['STAR_IMPORTS_CONSIDERED_HARMFUL']

# ....................{ CONSTANTS                         }....................
_CODE_TYPISTRY_NAME_TO_OBJECT = '__beartypistry[{!r}]'
'''
Python expression evaluating to an arbitrary object referenced by the
fully-qualified name formatted into this snippet by the caller from the private
``__beartypistry`` parameter implicitly passed to all wrapper functions
generated by the :func:`beartype.beartype` decorator.
'''

# ....................{ REGISTRARS                        }....................
def register_typistry_type(cls: type) -> str:
    '''
    Register the passed type with the beartypistry singleton *and* return a
    Python expression evaluating to this type when accessed via the private
    ``__beartypistry`` parameter implicitly passed to all wrapper functions
    generated by the :func:`beartype.beartype` decorator.

    This function is syntactic sugar improving consistency throughout the
    codebase, but is otherwise roughly equivalent to:

        >>> from beartype._decor._typistry import bear_typistry
        >>> from beartype._util.utilobject import get_object_name_qualified
        >>> bear_typistry[get_object_name_qualified(cls)] = cls

    This function is memoized for efficiency.

    Caveats
    ----------
    **There intentionally exists no corresponding** ``register_tuple()``
    **function,** as that function would offer no meaningful benefit over the
    existing public :data:`bear_typistry` singleton. Whereas types publish
    the fully-qualified names of the module attribute declaring those types via
    dunder attributes on those types (e.g., ``__module__``), no similar dunder
    attributes exist for arbitrary objects in general or tuples in specific.

    Parameters
    ----------
    cls : type
        Type to be registered.

    Raises
    ----------
    _BeartypeDecorBeartypistryException
        If this type is *not* a type.
    '''

    # If this type is *NOT* actually a type, raise an exception.
    if not isinstance(cls, type):
        raise _BeartypeDecorBeartypistryException(
            'Non-class {!r} unsupported by "bear_typistry".'.format(cls))
    # If this type is defined by the "typing" module, raise an exception.
    elif is_hint_pep(cls):
        raise _BeartypeDecorBeartypistryException(
            '"Typing" type {!r} unsupported by "bear_typistry".'.format(cls))
    # Else, this type is *NOT* defined by the "typing" module.

    # Fully-qualified name of this type.
    clsname = get_object_name_qualified(cls)

    # Register this type with the beartypistry singleton.
    bear_typistry[clsname] = cls

    # Return a Python expression evaluating to this type.
    return _CODE_TYPISTRY_NAME_TO_OBJECT.format(clsname)

# ....................{ CLASSES                           }....................
class Beartypistry(dict):
    '''
    **Beartypistry** (i.e., singleton dictionary mapping from the
    fully-qualified classnames of all type hints annotating callables decorated
    by the :func:`beartype.beartype` decorator to those types).**

    This dictionary implements a global registry for annotation types shared
    across *all* type-checking wrapper functions generated by that decorator,
    enabling these wrappers to:

    * Trivially obtain type objects at wrapper runtime given only the
      fully-qualified classnames of those objects hard-coded into the bodies of
      those wrappers at decoration time.
    * Trivially resolve **forward references** (i.e., type hints whose values
      are fully-qualified classnames) at wrapper runtime, which this dictionary
      facilitates by defining a dictionary-specific :meth:`__missing__` dunder
      method dynamically adding a new mapping from such a reference to the
      corresponding type on the first attempt to access such a reference.
    '''

    # ..................{ DUNDERS                           }..................
    def __setitem__(self, hint_name: str, hint: object) -> None:
        '''
        Dunder method explicitly called by the superclass on setting the passed
        key-value pair with``[``- and ``]``-delimited syntax, mapping the name
        of the module attribute declaring the passed :mod:`beartype`-supported
        type hint to that hint.

        Specifically, this method:

        #. Validates the types of this pair.
        #. Sets this pair on this dictionary.

        Parameters
        ----------
        hint_name: str : str
            **Name** (i.e., fully-qualified name of the module attribute
            declaring this hint) of this hint.
        hint: object
            :mod:`beartype`-supported type hint to map to this name to.

        Raises
        ----------
        TypeError
            If this hint is **unhashable** (i.e., *not* hashable by the builtin
            :func:`hash` function and thus unusable in hash-based containers
            like dictionaries and sets). All supported type hints are hashable.
        BeartypeDecorHintNonPepException
            If this hint is hashable but is neither a PEP-compliant nor
            -noncompliant type hint.
        _BeartypeCallBeartypistryException
            If either:

            * This name is *not* a string.
            * This hint is a type but this name is *not* the fully-qualified
              classname of that type.
        '''

        # If this name is *NOT* a string, raise an exception.
        if not isinstance(hint_name, str):
            raise _BeartypeCallBeartypistryException(
                'Beartypistry key {!r} not a '
                'fully-qualified module attribute name.'.format(hint_name))

        # If this hint is *NOT* a valid hint, raise an exception.
        die_unless_hint(
            hint=hint,
            hint_label='Beartypistry value {!r}'.format(hint),
            is_str_valid=False,
        )

        # If this hint is a type...
        if isinstance(hint, type):
            # Fully-qualified name of this type as declared by this type.
            clsname = get_object_name_qualified(hint)

            # If the passed name is *NOT* this name, raise an exception.
            if hint_name != clsname:
                raise _BeartypeCallBeartypistryException(
                    'Beartypistry key "{}" not '
                    'classname "{}" of type {!r}.'.format(
                        hint_name, clsname, hint))

        # Map this classname to this class.
        super().__setitem__(hint_name, hint)


    def __missing__(self, hint_name: str) -> type:
        '''
        Dunder method explicitly called by the superclass
        :meth:`dict.__getitem__` method implicitly called on getting the passed
        missing key with ``[``- and ``]``-delimited syntax.

        This method treats this attempt to get this missing key as the
        intentional resolution of a forward reference whose fully-qualified
        classname is this key. Specifically, this method:

        #.

        Parameters
        ----------
        hint_name : str
            **Name** (i.e., fully-qualified name of the module attribute
            declaring this hint) of this hint to be resolved as a forward
            reference.

        Returns
        ----------
        object
            :mod:`beartype`-supported type hint whose fully-qualified module
            attribute name is this missing key.

        Raises
        ----------
        _BeartypeCallBeartypistryException
            If this classname is either:

            * *Not* a string.
        '''

        # If this name is *NOT* a string, raise an exception.
        if not isinstance(hint_name, str):
            raise _BeartypeCallBeartypistryException(
                'Beartypistry key {!r} not a '
                'fully-qualified module attribute name.'.format(hint_name))

        #FIXME: Dynamically import this object here.
        # Type hint dynamically imported from this name.
        hint = None

        # If this hint is *NOT* a valid hint, raise an exception.
        die_unless_hint(
            hint=hint,
            hint_label='Beartypistry value {!r}'.format(hint),
            is_str_valid=False,
        )

        # Return this hint.
        #
        # The superclass dict.__getitem__() dunder method then implicitly maps
        # the passed missing key to this class by effectively:
        #     self[hint_name] = hint
        return hint

# ....................{ SINGLETONS                        }....................
bear_typistry = Beartypistry()
'''
**Beartypistry** (i.e., singleton dictionary mapping from the fully-qualified
classnames of all type hints annotating callables decorated by the
:func:`beartype.beartype` decorator to those types).**

See Also
----------
:class:`Beartypistry`
    Further details.
'''
