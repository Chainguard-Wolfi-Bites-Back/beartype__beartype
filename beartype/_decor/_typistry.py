#!/usr/bin/env python3
# --------------------( LICENSE                           )--------------------
# Copyright (c) 2014-2020 Cecil Curry.
# See "LICENSE" for further details.

'''
**Beartypistry** (i.e., singleton dictionary mapping from the fully-qualified
classnames of all type hints annotating callables decorated by the
:func:`beartype.beartype` decorator to those types).**

This private submodule is *not* intended for importation by downstream callers.
'''

# ....................{ IMPORTS                           }....................
from beartype.roar import (
    _BeartypeDecorBeartypistryException,
    _BeartypeCallBeartypistryException,
)
from beartype._util.utilobject import get_object_name_qualified
from beartype._util.cache.utilcachecall import callable_cached
from beartype._util.hint.nonpep.utilhintnonpeptest import (
    die_unless_hint_nonpep)
from beartype._util.hint.pep.utilhintpeptest import die_if_hint_pep

# See the "beartype.__init__" submodule for further commentary.
__all__ = ['STAR_IMPORTS_CONSIDERED_HARMFUL']

# ....................{ CONSTANTS                         }....................
_CODE_TYPISTRY_HINT_NAME_TO_HINT = '__beartypistry[{!r}]'
'''
Python expression evaluating to an arbitrary object referenced by the
fully-qualified name formatted into this snippet by the caller from the private
``__beartypistry`` parameter implicitly passed to all wrapper functions
generated by the :func:`beartype.beartype` decorator.
'''


_TYPISTRY_HINT_NAME_TUPLE_PREFIX = '+'
'''
**Beartypistry tuple key prefix** (i.e., substring prefixing the keys of all
:data:`__bear_typistry` key-value pairs whose values are tuples).

Since fully-qualified classnames are guaranteed *not* to be prefixed by this
prefix, this prefix suffices to uniquely distinguish key-value pairs whose
values are types from pairs whose values are tuples.
'''

# ....................{ REGISTRARS                        }....................
@callable_cached
def register_typistry_type(cls: type) -> str:
    '''
    Register the passed type with the beartypistry singleton *and* return a
    Python expression evaluating to this type when accessed via the private
    ``__beartypistry`` parameter implicitly passed to all wrapper functions
    generated by the :func:`beartype.beartype` decorator.

    This function is syntactic sugar improving consistency throughout the
    codebase, but is otherwise roughly equivalent to:

        >>> from beartype._decor._typistry import bear_typistry
        >>> from beartype._util.utilobject import get_object_name_qualified
        >>> bear_typistry[get_object_name_qualified(cls)] = cls

    This function is memoized for efficiency.

    Parameters
    ----------
    cls : type
        Type to be registered.

    Raises
    ----------
    _BeartypeDecorBeartypistryException
        If this object is either:

        * *Not* a type.
        * A :mod:`typing` type (i.e., class either defined by the
          :mod:`typing` module or subclassing such a class and thus a
          PEP-compliant type hint or object satisfying such a hint, all of
          which typically violate standard type semantics and thus require
          PEP-specific handling).
    '''

    # If this object is *NOT* a type, raise an exception.
    if not isinstance(cls, type):
        raise _BeartypeDecorBeartypistryException(
            'Beartypistry type {!r} not a type.'.format(cls))
    # Else, this object is a type.

    # If this type is PEP-compliant, raise an exception.
    die_if_hint_pep(
        hint=cls,
        hint_label='Beartypistry type ' + repr(cls),
        exception_cls=_BeartypeDecorBeartypistryException,
    )
    # Else, this type is PEP-noncompliant.

    # Fully-qualified name of this type.
    clsname = get_object_name_qualified(cls)

    # Register this type with the beartypistry singleton.
    bear_typistry[clsname] = cls

    # Return a Python expression evaluating to this type.
    return _CODE_TYPISTRY_HINT_NAME_TO_HINT.format(clsname)

# ....................{ REGISTRARS ~ tuple                }....................
#FIXME: Unit test us up.
#FIXME: Implement us up.
@callable_cached
def register_typistry_tuple_from_set(tuple_set: set) -> str:
    '''
    Register the passed set with the beartypistry singleton as a tuple of all
    items in this set *and* return a Python expression evaluating to this tuple
    when accessed via the private ``__beartypistry`` parameter implicitly
    passed to all wrapper functions generated by the :func:`beartype.beartype`
    decorator.

    This function is memoized for efficiency.

    Parameters
    ----------
    tuple_set : type
        Set of all tuple items to be registered.

    Raises
    ----------
    _BeartypeDecorBeartypistryException
        If this set is *not* a set.
    '''

    pass

# ....................{ CLASSES                           }....................
class Beartypistry(dict):
    '''
    **Beartypistry** (i.e., singleton dictionary mapping from strings uniquely
    identifying PEP-noncompliant type hints annotating callables decorated
    by the :func:`beartype.beartype` decorator to those hints).**

    This dictionary implements a global registry for **PEP-noncompliant type
    hints** (i.e., :mod:`beartype`-specific annotation *not* compliant with
    annotation-centric PEPs), including:

    * Non-:mod:`typing` types (i.e., classes *not* defined by the :mod:`typing`
      module, which are PEP-compliant type hints that fail to comply with
      standard type semantics and are thus beyond the limited scope of this
      PEP-noncompliant-specific dictionary).
    * Tuples of non-:mod:`typing` types, commonly referred to as **tuple
      unions** in :mod:`beartype` jargon.

    This dictionary efficiently shares these hints across all type-checking
    wrapper functions generated by this decorator, enabling these functions to:

    * Obtain type and tuple objects at wrapper runtime given only the strings
      uniquely identifying those objects hard-coded into the bodies of those
      wrappers at decoration time.
    * Resolve **forward references** (i.e., type hints whose values are strings
      uniquely identifying type and tuple objects) at wrapper runtime, which
      this dictionary supports by defining a :meth:`__missing__` dunder method
      dynamically adding a new mapping from each such reference to the
      corresponding object on the first attempt to access that reference.
    '''

    # ..................{ DUNDERS                           }..................
    def __setitem__(self, hint_name: str, hint: object) -> None:
        '''
        Dunder method explicitly called by the superclass on setting the passed
        key-value pair with``[``- and ``]``-delimited syntax, mapping the
        passed string uniquely identifying the passed PEP-noncompliant type
        hint to that hint.

        Parameters
        ----------
        hint_name: str : str
            String uniquely identifying this hint in a manner dependent on the
            type of this hint. Specifically, if this hint is:

            * A non-:mod:`typing` type, this is the fully-qualified classname
              of the module attribute defining this type.
            * A tuple of non-:mod:`typing` types, this is a string:

              * Prefixed by the :data:`_TYPISTRY_HINT_NAME_TUPLE_PREFIX`
                substring distinguishing this string from fully-qualified
                classnames.
              * Hash of these types (ignoring duplicate types and type order in
                this tuple).

        Raises
        ----------
        TypeError
            If this hint is **unhashable** (i.e., *not* hashable by the builtin
            :func:`hash` function and thus unusable in hash-based containers
            like dictionaries and sets). All supported type hints are hashable.
        BeartypeDecorHintNonPepException
            If this hint is hashable but is neither a PEP-compliant nor
            -noncompliant type hint.
        _BeartypeCallBeartypistryException
            If either:

            * This name is *not* a string.
            * This hint is a type but this name is *not* the fully-qualified
              classname of that type.
        '''

        # If this name is *NOT* a string, raise an exception.
        if not isinstance(hint_name, str):
            raise _BeartypeCallBeartypistryException(
                'Beartypistry key {!r} not a string.'.format(hint_name))

        # If this hint is *NOT* a valid hint, raise an exception.
        die_unless_hint_nonpep(
            hint=hint,
            hint_label='Beartypistry value' + repr(hint),
            is_str_valid=False,
        )

        # If this hint is a type...
        if isinstance(hint, type):
            # Fully-qualified name of this type as declared by this type.
            clsname = get_object_name_qualified(hint)

            # If the passed name is *NOT* this name, raise an exception.
            if hint_name != clsname:
                raise _BeartypeCallBeartypistryException(
                    'Beartypistry key "{}" not '
                    'classname "{}" of type {!r}.'.format(
                        hint_name, clsname, hint))

        # Map this classname to this class.
        super().__setitem__(hint_name, hint)


    def __missing__(self, hint_name: str) -> type:
        '''
        Dunder method explicitly called by the superclass
        :meth:`dict.__getitem__` method implicitly called on getting the passed
        missing key with ``[``- and ``]``-delimited syntax.

        This method treats this attempt to get this missing key as the
        intentional resolution of a forward reference whose fully-qualified
        classname is this key. Specifically, this method:

        #.

        Parameters
        ----------
        hint_name : str
            **Name** (i.e., fully-qualified name of the module attribute
            declaring this hint) of this hint to be resolved as a forward
            reference.

        Returns
        ----------
        object
            :mod:`beartype`-supported type hint whose fully-qualified module
            attribute name is this missing key.

        Raises
        ----------
        _BeartypeCallBeartypistryException
            If this name is either:

            * *Not* a fully-qualified classname.
            * A fully-qualified classname but the object to which this name
              refers is *not* a **PEP-noncompliant class** (i.e., class neither
              defined by the :mod:`typing` module *nor* subclassing a class
              defined by the :mod:`typing` module).
        '''

        # If this name is *NOT* a string, raise an exception.
        if not isinstance(hint_name, str):
            raise _BeartypeCallBeartypistryException(
                'Beartypistry key {!r} not a '
                'fully-qualified module attribute name.'.format(hint_name))

        #FIXME: Dynamically import this object here.
        # Type hint dynamically imported from this name.
        hint = None

        # If this hint is *NOT* a valid PEP-noncompliant type hint, raise an
        # exception.
        die_unless_hint_nonpep(
            hint=hint,
            hint_label='Beartypistry value {!r}'.format(hint),
            is_str_valid=False,
            exception_cls=_BeartypeCallBeartypistryException,
        )

        # Return this hint.
        #
        # The superclass dict.__getitem__() dunder method then implicitly maps
        # the passed missing key to this class by effectively:
        #     self[hint_name] = hint
        return hint

# ....................{ SINGLETONS                        }....................
bear_typistry = Beartypistry()
'''
**Beartypistry** (i.e., singleton dictionary mapping from the fully-qualified
classnames of all type hints annotating callables decorated by the
:func:`beartype.beartype` decorator to those types).**

See Also
----------
:class:`Beartypistry`
    Further details.
'''
