#!/usr/bin/env python3
# --------------------( LICENSE                           )--------------------
# Copyright (c) 2014-2020 Cecil Curry.
# See "LICENSE" for further details.

'''
**Beartypistry** (i.e., singleton dictionary mapping from the fully-qualified
classnames of all type hints annotating callables decorated by the
:func:`beartype.beartype` decorator to those types).**

This private submodule is *not* intended for importation by downstream callers.
'''

# ....................{ IMPORTS                           }....................
from beartype.roar import BeartypeCallBeartypistryException
from beartype._util import utilobj

# See the "beartype.__init__" submodule for further commentary.
__all__ = ['STAR_IMPORTS_CONSIDERED_HARMFUL']

# ....................{ REGISTRARS                        }....................
def register_type(cls: type) -> None:
    '''
    Register the passed type with the beartypistry singleton.

    This function is syntactic sugar improving consistency throughout the
    codebase, but is otherwise equivalent to:

        >>> from beartype._decor._typistry import BEARTYPISTRY
        >>> from beartype._util import utilobj
        >>> BEARTYPISTRY[utilobj.get_name_qualified(cls)] = cls

    Parameters
    ----------
    cls : type
        Class to be registered.
    '''

    # One-liners for reasonable justice.
    #
    # Note that both the utilobj.get_name_qualified() function explicitly
    # called here *AND* the Beartypistry.__setitem__() dunder method implicitly
    # called by this assignment validate their passed argument(s). Ergo, avoid
    # doing so here to preserve DRY.
    BEARTYPISTRY[utilobj.get_name_qualified(cls)] = cls

# ....................{ CLASSES                           }....................
class Beartypistry(dict):
    '''
    **Beartypistry** (i.e., singleton dictionary mapping from the
    fully-qualified classnames of all type hints annotating callables decorated
    by the :func:`beartype.beartype` decorator to those types).**

    This dictionary implements a global registry for annotation types shared
    across *all* type-checking wrapper functions generated by that decorator,
    enabling these wrappers to:

    * Trivially obtain type objects at wrapper runtime given only the
      fully-qualified classnames of those objects hard-coded into the bodies of
      those wrappers at decoration time.
    * Trivially resolve **forward references** (i.e., type hints whose values
      are fully-qualified classnames) at wrapper runtime, which this dictionary
      facilitates by defining a dictionary-specific :meth:`__missing__` dunder
      method dynamically adding a new mapping from such a reference to the
      corresponding type on the first attempt to access such a reference.
    '''

    # ..................{ DUNDERS                           }..................
    def __setitem__(self, clsname: str, cls: type) -> None:
        '''
        Dunder method explicitly called by the superclass on setting the passed
        key-value pair with``[``- and ``]``-delimited syntax.

        Specifically, this method:

        #. Validates the types of this pair.
        #. Sets this pair on this dictionary.

        Parameters
        ----------
        clsname : str
            Fully-qualified classname to map this class to.
        cls : type
            Class to be mapped to.

        Raises
        ----------
        BeartypeCallBeartypistryException
            If either:

            * This key is *not* the fully-qualified classname of this class.
            * This value is *not* a class.
        '''

        # If this classname is *NOT* a string, raise an exception.
        if not isinstance(clsname, str):
            raise BeartypeCallBeartypistryException(
                'Beartypistry key {!r} not a '
                'fully-qualified classname.'.format(clsname))

        # If this class is *NOT* a class, raise an exception.
        if not isinstance(cls, type):
            raise BeartypeCallBeartypistryException(
                'Beartypistry value {!r} not a class.'.format(cls))

        # Fully-qualified name of this class as declared by this class.
        clsname_true = utilobj.get_name_qualified(cls)

        # If the passed classname is *NOT* the actual classname, raise an
        # exception.
        if clsname != clsname_true:
            raise BeartypeCallBeartypistryException(
                'Beartypistry classname "{}" not '
                'the actual classname "{}" of type {!r}.'.format(
                    clsname, clsname_true, cls))

        # Map this classname to this class.
        super().__setitem__(clsname, cls)


    def __missing__(self, clsname: str) -> type:
        '''
        Dunder method explicitly called by the superclass
        :meth:`dict.__getitem__` method implicitly called on getting the passed
        missing key with ``[``- and ``]``-delimited syntax.

        This method treats this attempt to get this missing key as the
        intentional resolution of a forward reference whose fully-qualified
        classname is this key. Specifically, this method:

        #.

        Parameters
        ----------
        clsname : str
            Fully-qualified classname to be resolved as a forward reference.

        Returns
        ----------
        type
            Class whose fully-qualified classname is this missing key.

        Raises
        ----------
        BeartypeCallBeartypistryException
            If this classname is either:

            * *Not* a string.
        '''

        # If this classname is *NOT* a string, raise an exception.
        if not isinstance(clsname, str):
            raise BeartypeCallBeartypistryException(
                'Beartypistry key {!r} not a '
                'fully-qualified classname.'.format(clsname))

        #FIXME: Dynamically import this type here.
        # Class dynamically imported as this classname.
        cls = None

        # If this class is *NOT* a class, raise an exception.
        if not isinstance(cls, type):
            raise BeartypeCallBeartypistryException(
                'Beartypistry classname "{}" '
                'value {!r} not a class.'.format(clsname, cls))

        # Return this class.
        #
        # The superclass dict.__getitem__() dunder method then implicitly maps
        # the passed missing key to this class by effectively:
        #     self[clsname] = cls
        return cls

# ....................{ SINGLETONS                        }....................
BEARTYPISTRY = Beartypistry()
'''
**Beartypistry** (i.e., singleton dictionary mapping from the fully-qualified
classnames of all type hints annotating callables decorated by the
:func:`beartype.beartype` decorator to those types).**

See Also
----------
:class:`Beartypistry`
    Further details.
'''
