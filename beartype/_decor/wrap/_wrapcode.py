#!/usr/bin/env python3
# --------------------( LICENSE                            )--------------------
# Copyright (c) 2014-2024 Beartype authors.
# See "LICENSE" for further details.

'''
**Beartype type-checking wrapper function code factories** (i.e., low-level
callables dynamically generating pure-Python code snippets type-checking
parameters and return values of :mod:`beartype`-decorated callables against the
PEP-compliant type hints annotating those callables).

This private submodule is *not* intended for importation by downstream callers.
'''

# ....................{ IMPORTS                            }....................
from beartype.typing import Optional
from beartype._cave._cavemap import NoneTypeOr
from beartype._check.checkmagic import (
    ARG_NAME_GETRANDBITS,
    ARG_NAME_WARN,
)
from beartype._check.code.codemake import make_check_expr
from beartype._conf.confcls import BeartypeConf
from beartype._data.func.datafuncarg import ARG_NAME_RETURN
from beartype._data.hint.datahinttyping import (
    CodeGenerated,
    LexicalScope,
    TypeStack,
)
from beartype._decor.wrap.wrapsnip import (
    CODE_HINT_ROOT_PREFIX,
    CODE_HINT_ROOT_SUFFIX,
    CODE_HINT_ROOT_SUFFIX_CLS_STACK,
    CODE_HINT_ROOT_SUFFIX_RANDOM_INT,
    CODE_HINT_VIOLATION_RAISE,
    CODE_HINT_VIOLATION_WARN,
)
from beartype._util.cache.utilcachecall import callable_cached
from warnings import warn

# ....................{ FACTORIES                          }....................
#FIXME: Unit test us up, please.
@callable_cached
def make_func_pith_code(
    hint: object,
    conf: BeartypeConf,
    cls_stack: TypeStack,
    pith_name: Optional[str],
) -> CodeGenerated:
    '''
    **Type-checking wrapper function code factory** (i.e., low-level function
    dynamically generating a pure-Python code snippet type-checking the
    previously localized parameter or return annotated by the passed type hint
    against that hint of the current :mod:`beartype`-decorated callable).

    This code factory is memoized for efficiency.

    Parameters
    ----------
    hint : object
        Type hint to be type-checked.
    conf : BeartypeConf
        **Beartype configuration** (i.e., self-caching dataclass encapsulating
        all settings configuring type-checking for the passed object).
    cls_stack : TypeStack
        **Type stack** (i.e., either a tuple of the one or more
        :func:`beartype.beartype`-decorated classes lexically containing the
        class variable or method annotated by this hint *or* :data:`None`).
    pith_name : Optional[str]
        Either:

        * If this hint annotates a parameter of some callable, the name of that
          parameter.
        * If this hint annotates the return of some callable, ``"return"``.
        * Else, :data:`None`.

    Returns
    -------
    CodeGenerated
        Tuple containing the Python code snippet dynamically generated by this
        code factory and metadata describing that code. See the
        :attr:`beartype._data.hint.datahinttyping.CodeGenerated` type hint for
        details.

    Raises
    ------
    All exceptions raised by the lower-level :func:`make_check_expr` factory.

    Warns
    -----
    All warnings emitted by the lower-level :func:`make_check_expr` factory.

    See Also
    --------
    :func:`.make_check_expr`
        Further details.
    '''

    # Python code snippet comprising a single boolean expression type-checking
    # an arbitrary object against this hint.
    (
        func_wrapper_code_expr,
        func_wrapper_scope,
        hint_forwardrefs_class_basename,
    ) = make_check_expr(hint, conf, cls_stack)

    # Code snippet passing the current class stack if needed to type-check this
    # type hint, defaulting to *NOT* passing this.
    arg_cls_stack = CODE_HINT_ROOT_SUFFIX_CLS_STACK if cls_stack else ''

    # Code snippet passing the value of the random integer previously generated
    # for the current call to the exception-handling function call embedded in
    # the "CODE_HINT_ROOT_SUFFIX" snippet, defaulting to *NOT* passing this.
    arg_random_int = (
        CODE_HINT_ROOT_SUFFIX_RANDOM_INT
        if ARG_NAME_GETRANDBITS in func_wrapper_scope else
        ''
    )

    #FIXME: [SPEED] Optimize the following two string munging operations into a
    #single string-munging operation resembling:
    #    func_wrapper_code = CODE_HINT_ROOT.format(
    #        check_expr=func_wrapper_code_expr,
    #        random_int_if_any=arg_random_int
    #    )
    #
    #Then define "CODE_HINT_ROOT" in the "wrapsnip" submodule to resemble:
    #    CODE_HINT_ROOT = (
    #        f'{CODE_HINT_ROOT_PREFIX}{{check_expr}}'
    #        f'{CODE_HINT_ROOT_SUFFIX}'
    #    )

    # Code snippet generating a human-readable violation exception or warning
    # when the root pith violates the root type hint.
    func_wrapper_code_suffix = CODE_HINT_ROOT_SUFFIX.format(
        arg_cls_stack=arg_cls_stack,
        arg_random_int=arg_random_int,
    )

    # Code snippet handling the previously generated violation by either raising
    # that violation as a fatal exception or emitting that violation as a
    # non-fatal warning.
    func_wrapper_code_violation = make_func_pith_code_violation(
        conf=conf,
        func_wrapper_scope=func_wrapper_scope,
        pith_name=pith_name,
    )

    # Code snippet type-checking the root pith against the root hint.
    func_wrapper_code = (
        f'{CODE_HINT_ROOT_PREFIX}'
        f'{func_wrapper_code_expr}'
        f'{func_wrapper_code_suffix}'
        f'{func_wrapper_code_violation}'
    )

    # Return all metadata required by higher-level callers.
    return (
        func_wrapper_code,
        func_wrapper_scope,
        hint_forwardrefs_class_basename,
    )


def make_func_pith_code_violation(
    conf: BeartypeConf,
    func_wrapper_scope: LexicalScope,
    pith_name: Optional[str],
) -> str:
    '''
    **Type-checking wrapper function code suffix factory** (i.e., low-level
    function dynamically generating a pure-Python code snippet either raising a
    fatal exception or emitting a non-fatal warning when the previously
    type-checked parameter or return annotated by the passed type hint violates
    that hint of the current :mod:`beartype`-decorated callable).

    This code factory is intentionally *not* memoized, as this low-level
    unmemoized function is only called by higher-level memoized functions.

    Parameters
    ----------
    conf : BeartypeConf
        **Beartype configuration** (i.e., self-caching dataclass encapsulating
        all settings configuring type-checking for the passed object).
    func_wrapper_scope : LexicalScope
        **Lexical scope** (i.e., dictionary mapping from the relative
        unqualified name to value of each locally or globally scoped attribute
        accessible to a callable or class).
    pith_name : Optional[str]
        Either:

        * If this hint annotates a parameter of some callable, the name of that
          parameter.
        * If this hint annotates the return of some callable, ``"return"``.
        * Else, :data:`None`.

    Returns
    -------
    CodeGenerated
        Tuple containing the Python code snippet dynamically generated by this
        code factory and metadata describing that code. See the
        :attr:`beartype._data.hint.datahinttyping.CodeGenerated` type hint for
        details.

    Raises
    ------
    All exceptions raised by the lower-level :func:`make_check_expr` factory.

    Warns
    -----
    All warnings emitted by the lower-level :func:`make_check_expr` factory.

    See Also
    --------
    :func:`.make_check_expr`
        Further details.
    '''
    assert isinstance(conf, BeartypeConf), f'{repr(conf)} not configuration.'
    assert isinstance(func_wrapper_scope, dict), (
        f'{repr(func_wrapper_scope)} not dictionary.')
    assert isinstance(pith_name, NoneTypeOr[str]), (
        f'{repr(pith_name)} neither string nor "None".')

    # Code snippet handling the previously generated violation by either raising
    # that violation as a fatal exception or emitting that violation as a
    # non-fatal warning, contextually initialized below.
    func_wrapper_code_violation = ''  # type: ignore[assignment]

    # If this code snippet produces this violation by emitting a non-fatal
    # warning (rather than raising an exception), detected as either...
    if (
        # If this object is neither a parameter nor return of a decorated
        # callable, this object was directly passed to either the
        # beartype.door.is_bearable() or beartype.door.die_if_unbearable()
        # functions. In either case, set this boolean to this previously
        # computed DOOR-specific boolean.
        conf._is_violation_door_warn if pith_name is None else
        # Else, this object is either a parameter or return of a decorated
        # callable.
        #
        # If this object is a return of a decorated callable, set this boolean
        # to this previously computed return-specific boolean.
        conf._is_violation_return_warn if pith_name == ARG_NAME_RETURN else
        # Else, this object is *NOT* a return of a decorated callable. In this
        # case, this object *MUST* be a parameter of a decorated callable. Set
        # this boolean to this previously computed parameter-specific boolean.
        conf._is_violation_param_warn
    ):
        # Emit a non-fatal warning.
        func_wrapper_code_violation = CODE_HINT_VIOLATION_WARN

        # Pass the warnings.warn() function required to emit this warning to
        # this wrapper function as an optional hidden parameter.
        func_wrapper_scope[ARG_NAME_WARN] = warn
    # Else...
    else:
        # Raise a fatal exception.
        func_wrapper_code_violation = CODE_HINT_VIOLATION_RAISE

    # Return this code snippet.
    return func_wrapper_code_violation
