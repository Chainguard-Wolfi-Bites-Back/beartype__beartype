#!/usr/bin/env python3
# --------------------( LICENSE                           )--------------------
# Copyright (c) 2014-2020 Cecil Curry.
# See "LICENSE" for further details.

'''
**Beartype decorator annotation introspection.**

This private submodule introspects the annotations of callables to be decorated
by the :func:`beartype.beartype` decorator in a general-purpose manner.

This private submodule is *not* intended for importation by downstream callers.
'''

# ....................{ IMPORTS                           }....................
from beartype.cave import (
    AnyType,
    ClassType,
)
from beartype._decor._code._snippet import (
    CODE_STR_IMPORT,
    CODE_STR_REPLACE,
    CODE_TUPLE_STR_TEST,
    CODE_TUPLE_STR_IMPORT,
    CODE_TUPLE_STR_APPEND,
    CODE_TUPLE_CLASS_APPEND,
    CODE_TUPLE_REPLACE,
)
from typing import Any

# See the "beartype.__init__" submodule for further commentary.
__all__ = ['STAR_IMPORTS_CONSIDERED_HARMFUL']

# ....................{ CONSTANTS                         }....................
HINTS_IGNORABLE = {AnyType, Any,}
'''
Set of all annotation objects to be unconditionally ignored during
annotation-based type checking in the :func:`beartype` decorator regardless of
callable context (e.g., parameter, return value).

This includes:

* The :class:`AnyType` type, synonymous with the builtin :class:`object` type.
  Since :class:`object` is the transitive superclass of all classes, parameters
  annotated as :class:`object` unconditionally match *all* objects under
  :func:`isinstance`-based type covariance and are thus equivalent to
  unannotated parameters.
* The `PEP 484`_-specific :class:`Any` type, functionally synonymous with the
  :class:`AnyType` and hence :class:`object` classes. Although `PEP
  484`_-specific logic should typically be isolated to the private
  :mod:`beartype._decor.pep484` subpackage for maintainability, listing this
  type here *improves* maintainability by centralizing similar logic.

.. _PEP 484:
   https://www.python.org/dev/peps/pep-0484
'''

# ....................{ CONSTANTS ~ private               }....................
_HINT_TUPLE_ITEM_VALID_TYPES = (ClassType, str)
'''
Tuple of all **valid :class:`tuple` annotation item types** (i.e., classes
whose instances are suitable as the items of any :class:`tuple` hinted for a
callable annotation type-checked with the :func:`beartype` decorator).

Specifically, this tuple contains:

* The **type of all classes,** as :func:`beartype` naturally accepts types as
  type hints.
* The **string type,** as :func:`beartype` also accepts strings (denoted
  "forward references") as type hints referring to the fully-qualified names of
  types dynamically resolved later at call time rather than earlier at
  decoration time.
'''

# ....................{ CODERS                            }....................
#FIXME: Refactor this function to leverage the "__beartypistry" parameter
#passed to all wrapper functions. Doing so will *SUBSTANTIALLY* simplify this
#function's implementation as well as improving efficiency. So, how do we do
#this? Simple:
#
#* Implement the Beartypistry.__missing__() dunder method, which currently only
#  sports an untested partial implementation.
#* If the passed "hint" is a string, *NO ADDITIONAL LOGIC WHATSOEVER IS
#  REQUIRED.* Indeed, this function needn't be called at all. Instead, the
#  parent function(s) should be refactored as follows:
#  * If the current type hint is a "type", the parent function(s) itself (i.e.,
#    *NOT* the wrapper function generated by that function) should explicitly
#    register that type with the beartypistry at decoration time: e.g.,
#      _typistry.register_type(hint)
#  * If the current type hint is either a "type" *OR* a "str", that hint's
#    class is trivially accessible from the body of the wrapper function as:
#      '''__beartypistry[{hint_clsname}]'''.format(hint_clsname)
#    ...where "hint_clsname" is trivially embeddable in that body as a string
#    obtained in the parent function(s) itself via:
#      hint_clsname = utilobj.get_name_qualified(hint)
#    This "just works." If this hint is a type, that type is guaranteed to have
#    already been registered with the beartypistry; else, this hint is a
#    string, in which case the __beartypistry.__missing__() dunder method will
#    dynamically import and register that type on its first access. Sweet, eh?
#* If the passed "hint" is a tuple, we probably want to preserve something
#  resembling the current approach. Technically, we *COULD* embed a dynamically
#  created tuple whose string items are all replaced with "__beartypistry"
#  lookups in the wrapper function. The issue with that, of course, is that
#  each call to that function would then uselessly recreate that tuple; so,
#  let's not do that. The current approach, while non-trivial, beneficially
#  avoids excessive garbage collection. Wacky idea of the evening:
#  * Define a private beartype-specific tuple subclass defining a __getitem__()
#    dunder method dynamically accessing the beartypistry. This will almost
#    certainly *NOT* work, as Python probably prohibits tuple subclasses from
#    overriding __getitem__(). Nonetheless, it's worth brief consideration.

def code_resolve_forward_refs(
    hint: object, hint_expr: str, hint_label: str) -> str:
    '''
    Python code snippet dynamically replacing all **forward references** (i.e.,
    fully-qualified classnames) in the passed annotation settable by the passed
    Python expression with the corresponding classes.

    Specifically, this function returns either:

    * If this annotation is a string, a snippet replacing this annotation with
      the class whose name is this string.
    * If this annotation is a tuple containing one or more strings, a snippet
      replacing this annotation with a new tuple such that each item of the
      original tuple that is:

      * A string is replaced with the class whose name is this string.
      * A class is preserved as is.

    * Else, the empty string (i.e., a noop).

    Parameters
    ----------
    hint : object
        Annotation to be inspected, assumed to be either a class,
        fully-qualified classname, or tuple of classes and/or classnames. Since
        the previously called :func:`verify_hint` function has already
        validated this to be the case, this assumption is *always* safe.
    hint_expr : str
        Python expression evaluating to the annotation to be replaced.
    hint_label : str
        Human-readable label describing this annotation, interpolated into
        exceptions raised by this function (e.g.,
        ``@beartyped myfunc() parameter "myparam" type annotation``).

    Returns
    ----------
    str
        Python code snippet dynamically replacing all classnames in the
        function annotation settable by this Python expression with the
        corresponding classes.
    '''
    assert isinstance(hint_expr, str), (
        '"{!r}" not a string.'.format(hint_expr))
    assert isinstance(hint_label, str), (
        '"{!r}" not a string.'.format(hint_label))

    #FIXME: Validate that all string classnames are valid Python identifiers
    #*BEFORE* generating code embedding these classnames. Sadly, doing so will
    #require duplicating existing "betse.util.py.pyident" code -- or, rather,
    #usage of the "IDENTIFIER_QUALIFIED_REGEX" global in that submodule.
    #
    #Note that efficiency is *NOT* a concern here, as less than 1% of all
    #parameter types to be validated will be specified as raw strings requiring
    #validation by regular expression here. Make it so, in other words.

    # If this annotation is a classname...
    if isinstance(hint, str):
        # Import statement importing the module defining this class if any
        # (i.e., if this classname contains at least one ".") *OR* the empty
        # string otherwise (i.e., if this class is a builtin type requiring no
        # explicit importation).
        hint_type_import_code = ''

        # If this classname contains at least one "." delimiter...
        if '.' in hint:
            # Fully-qualified module name and unqualified attribute basename
            # parsed from this classname. It is good.
            hint_type_module_name, hint_type_basename = (
                hint.rsplit(sep='.', maxsplit=1))

            # print('Importing "{hint_type_module_name}.{hint_type_basename}"...')
            # Import statement importing this module.
            hint_type_import_code = CODE_STR_IMPORT.format(
                hint_type_module_name=hint_type_module_name,
                hint_type_basename=hint_type_basename,
            )
        # Else, this classname contains *NO* "." delimiters and hence signifies
        # a builtin type (e.g., "int"). In this case, the unqualified basename
        # of this type is simply its classname.
        else:
            hint_type_basename = hint

        # Block of Python code to be returned.
        return CODE_STR_REPLACE.format(
            hint_expr=hint_expr,
            hint_label=hint_label,
            hint_type_basename=hint_type_basename,
            hint_type_import_code=hint_type_import_code,
        )
    # Else if this annotation is a tuple containing one or more classnames...
    elif isinstance(hint, tuple):
        # Tuple of the indices of all classnames in this annotation.
        hint_type_name_indices = tuple(
            subhint_index
            for subhint_index, subhint in enumerate(hint)
            if isinstance(subhint, str)
        )

        # If this annotation contains no classnames, this annotation requires
        # no replacement at runtime. Return the empty string signifying a noop.
        if not hint_type_name_indices:
            return ''
        # Else, this annotation contains one or more classnames...

        # String evaluating to the first classname in this annotation.
        subhint_type_name_expr = '{}[{}]'.format(
            hint_expr, hint_type_name_indices[0])

        # Block of Python code to be returned.
        #
        # Note that this approach is mildly inefficient, due to the need to
        # manually construct a list to be converted into the desired tuple. Due
        # to subtleties, this approach cannot be reasonably optimized by
        # directly producing the desired tuple without an intermediary tuple.
        # Why? Because this approach trivially circumvents class basename
        # collisions (e.g., between the hypothetical classnames "rising.Sun"
        # and "sinking.Sun", which share the same basename "Sun").
        hint_replacement_code = CODE_TUPLE_STR_TEST.format(
            subhint_type_name_expr=subhint_type_name_expr)

        # For the 0-based index of each item and that item of this
        # annotation...
        for subhint_index, subhint in enumerate(hint):
            # String evaluating to this item's annotated type.
            subhint_expr = '{}[{}]'.format(hint_expr, subhint_index)

            # If this item is a classname...
            if isinstance(subhint, str):
                # If this classname contains at least one "." delimiter...
                #
                # Note that the following logic is similar to but subtly
                # different enough from similar logic above that the two cannot
                # reasonably be unified into a general-purpose function.
                if '.' in subhint:
                    # Fully-qualified module name and unqualified attribute
                    # basename parsed from this classname. It is good.
                    subhint_type_module_name, subhint_type_basename = (
                        subhint.rsplit(sep='.', maxsplit=1))

                    # Import statement importing this module.
                    hint_replacement_code += (
                        CODE_TUPLE_STR_IMPORT.format(
                            subhint_type_module_name=subhint_type_module_name,
                            subhint_type_basename=subhint_type_basename,
                        ))
                # Else, this classname contains *NO* "." delimiters and hence
                # signifies a builtin type (e.g., "int"). In this case, the
                # unqualified basename of this this type is its classname.
                else:
                    subhint_type_basename = subhint

                # Block of Python code to be returned.
                hint_replacement_code += CODE_TUPLE_STR_APPEND.format(
                    hint_label=hint_label,
                    subhint_type_basename=subhint_type_basename,
                )
            # Else, this member is assumed to be a class. In this case...
            else:
                # Block of Python code to be returned.
                hint_replacement_code += CODE_TUPLE_CLASS_APPEND.format(
                    subhint_expr=subhint_expr)

        # Block of Python code to be returned.
        hint_replacement_code += CODE_TUPLE_REPLACE.format(
            hint_expr=hint_expr)

        # Return this block.
        return hint_replacement_code
    # Else, this annotation requires no replacement at runtime. In this case,
    # return the empty string signifying a noop.
    else:
        return ''
