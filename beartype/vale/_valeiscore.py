#!/usr/bin/env python3
# --------------------( LICENSE                           )--------------------
# Copyright (c) 2014-2021 Beartype authors.
# See "LICENSE" for further details.

'''
**Beartype core data validation classes.**

This private submodule defines the core low-level class hierarchy driving the
entire :mod:`beartype` data validation ecosystem.

This private submodule is *not* intended for importation by downstream callers.
'''

# ....................{ TODO                              }....................
# All "FIXME:" comments for this submodule reside in this package's "__init__"
# submodule to improve maintainability and readability here.

# ....................{ IMPORTS                           }....................
from beartype.roar import (
    BeartypeValeSubscriptedIsInitException,
    BeartypeValeSubscriptedIsLambdaWarning,
)
from beartype._util.cache.utilcachecall import callable_cached
from beartype._util.data.utildatadict import merge_mappings_two
from beartype._util.func.utilfuncarg import get_func_args_len_standard
from beartype._util.func.utilfunccode import get_func_code_or_none
from beartype._util.func.utilfuncscope import (
    CallableScope,
    add_func_scope_attr,
)
from beartype._util.func.utilfunctest import is_func_lambda
from beartype._util.func.utilfunctest import is_func_python
from beartype._util.text.utiltextrepr import get_object_representation
from typing import Any, Callable, Optional

# See the "beartype.cave" submodule for further commentary.
__all__ = ['STAR_IMPORTS_CONSIDERED_HARMFUL']

# ....................{ HINTS                             }....................
SubscriptedIsValidator = Callable[[Any,], bool]
'''
PEP-compliant type hint matching a **data validator** (i.e., caller-defined
function accepting a single arbitrary object and returning either ``True`` if
that object satisfies an arbitrary constraint or ``False`` otherwise).

Data validators are suitable for subscripting the :class:`Is` class.
'''

# ....................{ CLASSES ~ subscripted             }....................
class SubscriptedIs(object):
    '''
    **Beartype data validator** (i.e., object encapsulating a caller-defined
    data validation function returning ``True`` when an arbitrary object passed
    to that function satisfies an arbitrary constraint, suitable for
    subscripting (indexing) `PEP 593`_-compliant :attr:`typing.Annotated` type
    hints, which then enforce that validation on :mod:`beartype`-decorated
    callable parameters and returns annotated by those hints).

    Design
    ----------
    Whereas the :meth:`is_valid` function *must* always be defined, the
    :attr:`is_valid_code` instance variable *should* be defined to be
    non-``None`` where feasible. Equivalently, the code generated by this
    validator *must* remain strictly optional. Why? Because validators *must*
    remain usable by both:

    * External third-party consumers, who are unlikely to permit dynamic
      execution of arbitrary code for obvious and understandable security and
      stability reasons.
    * Internal :mod:`beartype` consumers prioritizing simplicity over
      efficiency (e.g., the private :mod:`beartype._decor._hint._pep._error`
      subpackage).

    Despite performing the same validation as the :meth:`is_valid` function,
    the :attr:`is_valid_code` snippet avoids the additional stack frame imposed
    by calling that function and thus constitutes an optimization. For
    efficiency, callers validating data through dynamically generated code
    (e.g., the :func:`beartype.beartype` decorator) rather than standard
    function calls (e.g., the private :mod:`beartype._decor._hint._pep._error`
    subpackage) should prefer :attr:`is_valid_code` to :meth:`is_valid`.

    Caveats
    ----------
    **This low-level class is not intended to be externally instantiated**
    (e.g., by calling the :meth:`__init__` constructor). This class is *only*
    intended to be internally instantiated by subscripting (indexing) the
    higher-level :class:`Is` class factory.

    Attributes
    ----------
    is_valid : Callable[[Any,], bool]
        **Data validator** (i.e., caller-defined function accepting a single
        arbitrary object and returning either ``True`` if that object satisfies
        an arbitrary constraint *or* ``False`` otherwise).
    is_valid_code : Optional[str]
        **Data validator code** (i.e., Python code snippet validating the
        previously localized parameter or return value against the same data
        validation performed by the :meth:`is_valid` function) if this data
        validator supports code generation *or* ``None`` otherwise (i.e., if
        this data validator does *not* support code generation). This code
        *must* contain one or more test subject substrings ``{obj}``, which
        code generators globally replace at dynamic execution time with the
        name of the actual object to be validated by this code.
    is_valid_code_locals : Optional[CallableScope]
        **Data validator code local scope** (i.e., dictionary mapping from the
        name to value of each local attribute referenced in the :attr:`code`
        code snippet) required to dynamically compile this data validator code
        into byte code at runtime if this data validator supports code
        generation *or* ``None`` otherwise (i.e., if this data validator does
        *not* support code generation).
    _get_repr : Callable[[], str]
        **Representer** (i.e., caller-defined callable accepting *no*
        arguments returning a machine-readable representation of this data
        validator). Technically, that representation *could* be passed by the
        caller rather than this callable dynamically generating that
        representation. Pragmatically, generating that representation is
        sufficiently slow for numerous types of data validators that deferring
        their generation until required by a call to the :meth:`__repr__`
        dunder method externally called by a call to the :func:`repr` builtin`
        on this data validator is effectively mandatory. Data validators whose
        representations are particularly slow to generate include:

        * The :class:`Is` class subscripted by a lambda rather than non-lambda
          function. Generating the representation of that class subscripted by
          a non-lambda function only requires introspecting the name of that
          function and is thus trivially fast. However, lambda functions have
          no names and are thus *only* distinguishable by their source code;
          ergo, generating the representation of that class subscripted by a
          lambda function requires parsing the source code of the file
          declaring that lambda for the exact substring of that code declaring
          that lambda and is thus non-trivially slow.

    See Also
    ----------
    :class:`Is`
        Class docstring for further details.

    .. _PEP 593:
       https://www.python.org/dev/peps/pep-0593
    '''

    # ..................{ CLASS VARIABLES                   }..................
    # Slot all instance variables defined on this object to minimize the time
    # complexity of both reading and writing variables across frequently called
    # cache dunder methods. Slotting has been shown to reduce read and write
    # costs by approximately ~10%, which is non-trivial.
    __slots__ = (
        'is_valid',
        'is_valid_code',
        'is_valid_code_locals',
        '_get_repr',
    )

    # ..................{ INITIALIZERS                      }..................
    def __init__(
        self,

        # Mandatory parameters.
        is_valid: SubscriptedIsValidator,
        get_repr: Callable[[], str],

        #FIXME: Make these mandatory, please. Doing so will require improving
        #the operators defined below. *sigh*

        # Optional parameters.
        is_valid_code: Optional[str] = None,
        is_valid_code_locals: Optional[CallableScope] = None,
    ) -> None:
        '''
        Initialize this object with the passed data validation function and
        optional data validation code and code local scope.

        See the class docstring for usage instructions.

        Parameters
        ----------
        is_valid : Callable[[Any,], bool]
            **Data is_valid** (i.e., caller-defined function accepting a
            single arbitrary object and returning either ``True`` if that
            object satisfies an arbitrary constraint *or* ``False`` otherwise).
        is_valid_code : Optional[str]
            **Data validator code** (i.e., Python code snippet validating the
            previously localized parameter or return value against the same
            data validation performed by the :meth:`is_valid` function) if this
            data validator supports code generation *or* ``None`` otherwise
            (i.e., if this data validator does *not* support code generation).
            This code *must* contain one or more test subject substrings
            ``{obj}``, which code generators globally replace at dynamic
            execution time with the name of the actual object to be validated
            by this code.
        is_valid_code_locals : Optional[CallableScope]
            **Data validator code local scope** (i.e., dictionary mapping from
            the name to value of each local attribute referenced in the
            :attr:`is_valid_code` code snippet) required to dynamically compile
            this data validator code into byte code at runtime if this data
            validator supports code generation *or* ``None`` otherwise (i.e.,
            if this data validator does *not* support code generation).
        get_repr : Callable[[], str]
            **Representer** (i.e., caller-defined callable accepting *no*
            arguments returning a machine-readable representation of this data
            validator). Technically, that representation rather than this
            callable dynamically generating that representation could be passed
            by the caller. Pragmatically, generating that representation is
            sufficiently slow for various types of data validators that
            deferring their generation until required by a call to the
            :meth:`__repr__` dunder method externally called by a call to the
            :func:`repr` builtin` passed this data validator is effectively
            mandatory. Data validators whose representations are particularly
            slow to generate include:

            * The :class:`Is` class subscripted by a lambda rather than
              non-lambda function. Generating the representation of that class
              subscripted by a non-lambda function only requires introspecting
              the name of that function and is thus trivially fast. However,
              lambda functions have no names and are thus *only*
              distinguishable by their source code; ergo, generating the
              representation of that class subscripted by a lambda function
              requires parsing the source code of the file declaring that
              lambda for the exact substring of that code declaring that lambda
              and is thus non-trivially slow.

        Raises
        ----------
        BeartypeValeSubscriptedIsInitException
            If either:

            * ``is_valid`` is either:

              * *Not* callable.
              * A C-based rather than pure-Python callable.
              * A pure-Python callable accepting two or more arguments.

            * ``is_valid_code`` is non-``None`` *and* either:

              * *Not* a string.
              * A string either:

                * Empty.
                * Non-empty but **invalid** (i.e., *not* containing the test
                  subject substring ``{obj}``).

              * ``is_valid_locals`` is ``None``.

            * ``is_valid_locals`` is non-``None`` but ``is_valid_code`` is
              ``None``.
        '''

        # If the parent "Is*" class was subscripted by either no arguments or
        # two or more arguments...
        if isinstance(is_valid, tuple):
            # If that class was subscripted by two or more arguments, raise an
            # exception.
            if is_valid:
                raise BeartypeValeSubscriptedIsInitException(
                    f'Class "beartype.vale.Is" subscripted by two or more '
                    f'arguments:\n{get_object_representation(is_valid)}'
                )
            # Else, that class was subscripted by *NO* arguments. In this case,
            # raise an exception.
            else:
                raise BeartypeValeSubscriptedIsInitException(
                    'Class "beartype.vale.Is" subscripted by empty tuple.')
        # Else, that class was subscripted by a single argument.
        #
        # If this argument is uncallable, raise an exception.
        elif not callable(is_valid):
            raise BeartypeValeSubscriptedIsInitException(
                f'Class "beartype.vale.Is" subscripted argument '
                f'{get_object_representation(is_valid)} not callable.'
            )
        # Else, this argument is callable.
        #
        # If this callable is C-based, raise an exception.
        elif not is_func_python(is_valid):
            raise BeartypeValeSubscriptedIsInitException(
                f'Class "beartype.vale.Is" subscripted callable '
                f'{repr(is_valid)} not pure-Python (e.g., C-based).'
            )
        # Else, this callable is pure-Python.
        #
        # If this callable does *NOT* accept exactly one argument, raise an
        # exception.
        elif get_func_args_len_standard(is_valid) != 1:
            raise BeartypeValeSubscriptedIsInitException(
                f'Class "beartype.vale.Is" subscripted callable '
                f'{repr(is_valid)} positional or keyword argument count '
                f'{get_func_args_len_standard(is_valid)} != 1.'
            )
        # Else, this callable accepts exactly one argument. Since no further
        # validation can be performed on this callable without unsafely calling
        # that callable, we accept this callable as is for now.
        #
        # Note that we *COULD* technically inspect annotations if defined on
        # this callable as well. Since this callable is typically defined as a
        # lambda, annotations are typically *NOT* defined on this callable.

        # If the caller passed code for this validator...
        if is_valid_code is not None:
            # If the caller passed *NO* code locals, raise an exception.
            if is_valid_code_locals is None:
                raise BeartypeValeSubscriptedIsInitException(
                    f'Data validator code locals unpassed but code passed:\n'
                    f'{is_valid_code}'
                )
            # Else, the caller passed code locals.
            #
            # If this code is *NOT* a string, raise an exception.
            elif not isinstance(is_valid_code, str):
                raise BeartypeValeSubscriptedIsInitException(
                    f'Data validator code not string:\n'
                    f'{get_object_representation(is_valid_code)}'
                )
            # Else, this code is a string.
            #
            # If this code is the empty string, raise an exception.
            elif not is_valid_code:
                raise BeartypeValeSubscriptedIsInitException(
                    'Data validator code empty.')
            # Else, this code is a non-empty string.
            #
            # If this code does *NOT* contain the test subject substring
            # "{obj}" and is invalid, raise an exception.
            elif '{obj}' not in is_valid_code:
                raise BeartypeValeSubscriptedIsInitException(
                    f'Data validator code invalid (i.e., test subject '
                    f'substring "{{obj}}" not found):\n{is_valid_code}'
                )
            # Else, this code is hopefully valid.
            #
            # If this code is *NOT* explicitly prefixed by "(" and suffixed by
            # ")", do so to ensure this code remains safely evaluable when
            # embedded in parent expressions.
            #FIXME: Unit test us up.
            elif not (
                is_valid_code[ 0] == '(' and
                is_valid_code[-1] == ')'
            ):
                is_valid_code = f'({is_valid_code})'
        # Else, the caller passed *NO* code for this validator.
        #
        # If the caller paradoxically passed code locals, raise an exception.
        elif is_valid_code_locals is not None:
            raise BeartypeValeSubscriptedIsInitException(
                f'Data validator code unpassed but code locals passed:\n'
                f'{get_object_representation(is_valid_code_locals)}'
            )
        # Else, the caller passed neither code nor code locals.

        # If this representer is either uncallable, a C-based callable, *OR* a
        # pure-Python callable accepting one or more arguments, raise an
        # exception.
        if get_func_args_len_standard(get_repr) != 0:
            raise BeartypeValeSubscriptedIsInitException(
                f'Representer {repr(get_repr)} positional or keyword argument '
                f'count {get_func_args_len_standard(get_repr)} != 0.'
            )
        # Else, this representer is a pure-Python callable accepting *NO*
        # arguments.

        # Classify this data validation function, effectively binding this
        # function to this object as an object-specific static method.
        self.is_valid = is_valid
        self.is_valid_code = is_valid_code
        self.is_valid_code_locals = is_valid_code_locals
        self._get_repr = get_repr

    # ..................{ DUNDERS ~ operator                }..................
    #FIXME: Optimize operators. When synthesizing lambda-style "SubscriptedIs"
    #objects, these operators currently generate *NO* code. They absolutely
    #should be, because adding stack frames just for this is absurd. To do so,
    #just add the lambda functions of each operand without code to the
    #"is_valid_locals" parameter of the new "SubscriptedIs" object.

    # Define a domain-specific language (DSL) enabling callers to dynamically
    # combine and Override
    def __and__(self, other: 'SubscriptedIs') -> (
        'SubscriptedIs'):
        '''
        **Conjunction** (i.e., ``self & other``), synthesizing a new
        :class:`SubscriptedIs` object whose data validator returns ``True`` only
        when the data validators of both this *and* the passed
        :class:`SubscriptedIs` objects all return ``True``.

        Parameters
        ----------
        other : SubscriptedIs
            Object to conjunctively synthesize with this object.

        Returns
        ----------
        SubscriptedIs
            New object conjunctively synthesized with this object.

        Raises
        ----------
        BeartypeValeSubscriptedIsInitException
            If the passed object is *not* also an instance of the same class.
        '''

        # If the passed object is *NOT* also an instance of this class, raise
        # an exception.
        if not isinstance(other, SubscriptedIs):
            raise BeartypeValeSubscriptedIsInitException(
                f'Subscripted "beartype.vale.Is*" class & operand '
                f'{get_object_representation(other)} not '
                f'subscripted "beartype.vale.Is*" class.'
            )
        # Else, the passed object is also an instance of this class.

        # Data validator code and locals of the new validator to be created,
        # defaulting to "None" for safety.
        is_valid_code: Optional[str] = None
        is_valid_code_locals: Optional[CallableScope] = None

        # If both this and that validator provide code...
        if self.is_valid_code and other.is_valid_code:
            # Generate code conjunctively performing both validations.
            is_valid_code = (
                f'({self.is_valid_code} and {other.is_valid_code})')

            # Generate locals safely merging the locals required by the code
            # provided by both this and that validator.
            is_valid_code_locals = merge_mappings_two(  # type: ignore[assignment]
                self.is_valid_code_locals, other.is_valid_code_locals)  # type: ignore[arg-type]
        # Else, either this or that validator do *NOT* provide code. In this
        # case, avoid generating any code for safety.

        # Closures for great justice.
        return SubscriptedIs(
            is_valid=lambda obj: self.is_valid(obj) and other.is_valid(obj),
            is_valid_code=is_valid_code,
            is_valid_code_locals=is_valid_code_locals,
            get_repr=lambda: f'{repr(self)} & {repr(other)}',
        )


    def __or__(self, other: 'SubscriptedIs') -> (
        'SubscriptedIs'):
        '''
        **Disjunction** (i.e., ``self | other``), synthesizing a new
        :class:`SubscriptedIs` object whose data validator returns ``True`` only
        when the data validators of either this *or* the passed
        :class:`SubscriptedIs` objects return ``True``.

        Parameters
        ----------
        other : SubscriptedIs
            Object to disjunctively synthesize with this object.

        Returns
        ----------
        SubscriptedIs
            New object disjunctively synthesized with this object.
        '''

        # If the passed object is *NOT* also an instance of this class, raise
        # an exception.
        if not isinstance(other, SubscriptedIs):
            raise BeartypeValeSubscriptedIsInitException(
                f'Subscripted "beartype.vale.Is*" class | operand '
                f'{get_object_representation(other)} not '
                f'subscripted "beartype.vale.Is*" class.'
            )
        # Else, the passed object is also an instance of this class.

        # Data validator code and locals of the new validator to be created,
        # defaulting to "None" for safety.
        is_valid_code: Optional[str] = None
        is_valid_code_locals: Optional[CallableScope] = None

        # If both this and that validator provide code...
        if self.is_valid_code and other.is_valid_code:
            # Generate code disjunctively performing both validations.
            is_valid_code = (
                f'({self.is_valid_code} or {other.is_valid_code})')

            # Generate locals safely merging the locals required by the code
            # provided by both this and that validator.
            is_valid_code_locals = merge_mappings_two(  # type: ignore[assignment]
                self.is_valid_code_locals, other.is_valid_code_locals)  # type: ignore[arg-type]
        # Else, either this or that validator do *NOT* provide code. In this
        # case, avoid generating any code for safety.

        # Closures for great justice.
        return SubscriptedIs(
            is_valid=lambda obj: self.is_valid(obj) or other.is_valid(obj),
            is_valid_code=is_valid_code,
            is_valid_code_locals=is_valid_code_locals,
            get_repr=lambda: f'{repr(self)} | {repr(other)}',
        )


    #FIXME: Fun optimization: if inverting something that's already been
    #inverted, return the original "SubscriptedIs" object sans inversion. :p
    def __invert__(self) -> 'SubscriptedIs':
        '''
        **Negation** (i.e., ``~self``), synthesizing a new
        :class:`SubscriptedIs` object whose data validator returns ``True``
        only when the data validators of this :class:`SubscriptedIs` object
        returns ``False``.

        Returns
        ----------
        SubscriptedIs
            New object negating this object.
        '''

        # Closures for profound lore.
        return SubscriptedIs(
            is_valid=lambda obj: not self.is_valid(obj),
            # Inverted data validator code, defined as either...
            is_valid_code=(
                # If this validator provides code, the trivial boolean negation
                # of that code;
                f'(not {self.is_valid_code})' if self.is_valid_code else
                # Else, "None".
                None
            ),
            is_valid_code_locals=self.is_valid_code_locals,
            get_repr=lambda: f'~{repr(self)}',
        )

    # ..................{ DUNDERS ~ str                     }..................
    @callable_cached
    def __repr__(self) -> str:
        '''
        Machine-readable representation of this data validator.

        This function is memoized for efficiency.

        Warns
        ----------
        BeartypeValeSubscriptedIsLambdaWarning
            If this data validator is implemented as a pure-Python lambda
            function whose definition is *not* parsable from the script or
            module defining that lambda.
        '''

        # Fight the dark power with... power.
        return self._get_repr()

# ....................{ CLASSES ~ subscriptable           }....................
class Is(object):
    '''
    **Beartype data validator factory** (i.e., class that, when subscripted
    (indexed) by a caller-defined data validation function returning ``True``
    when an arbitrary object passed to that function satisfies an arbitrary
    constraint, creates a new :class:`SubscriptedIs` object encapsulating that
    function suitable for subscripting (indexing) :attr:`typing.Annotated` type
    hints, which then enforce that validation on :mod:`beartype`-decorated
    callable parameters and returns annotated by those hints).

    Subscripting (indexing) this class produces an :class:`SubscriptedIs`
    object that validates the internal integrity, consistency, and structure of
    arbitrary objects ranging from simple builtin scalars like integers and
    strings to complex data structures defined by third-party packages like
    NumPy arrays and Pandas DataFrames. For portability, :class:`SubscriptedIs`
    objects are:

    * **PEP-compliant** and thus guaranteed to *never* violate existing or
      future standards.
    * **Safely ignorable** by *all* static and runtime type checkers other than
      :mod:`beartype` itself.

    Usage
    ----------
    Callers are expected to (in order):

    #. Annotate a callable parameter or return to be validated with a `PEP
       593`_-compliant :attr:`typing.Annotated` type hint.
    #. Subscript that hint with (in order):

       #. The type expected by that parameter or return.
       #. One or more subscriptions (indexations) of this class, each itself
          subscripted (indexed) by a **data validator** (i.e., function
          accepting a single arbitrary object and returning either ``True`` if
          that object satisfies an arbitrary constraint *or* ``False``
          otherwise). If that hint is subscripted by:

          * Only one subscription of this class, that parameter or return
            satisfies that hint when both:

            * That parameter or return is an instance of the expected type.
            * That data validator returns ``True`` when passed that parameter
              or return.

          * Two or more subscriptions of this class, that parameter or return
            satisfies that hint when both:

            * That parameter or return is an instance of the expected type.
            * *All* data validators subscripting *all* subscriptions of this
              class return ``True`` when passed that parameter or return.

          Formally, the signature of each data validator *must* resemble:

          .. _code-block:: python

             def is_object_valid(obj) -> bool:
                 return bool(obj)

          Equivalently, each validator *must* satisfy the type hint
          ``collections.abc.Callable[[typing.Any,], bool]``. If not the case,
          an exception is raised. Note that:

          * If that parameter or return is *not* an instance of the expected
            type, **no validator is called.** Equivalently, each validator is
            called *only* when that parameter or return is already an instance
            of the expected type. Validators need *not* revalidate that type
            (e.g., by passing that parameter or return and type to the
            :func:`isinstance` builtin).
          * The name of each validator is irrelevant. For convenience, most
            validators are defined as nameless lambda functions.

    For example, the following type hint only accepts non-empty strings:

    .. _code-block:: python

       Annotated[str, Is[lambda text: bool(text)]]

    :class:`SubscriptedIs` objects also support an expressive domain-specific
    language (DSL) enabling callers to trivially synthesize new objects from
    existing objects with standard Pythonic math operators:

    * **Negation** (i.e., ``not``). Negating an :class:`SubscriptedIs` object
      with the ``~`` operator synthesizes a new :class:`SubscriptedIs` object
      whose data validator returns ``True`` only when the data validator of the
      original object returns ``False``. For example, the following type hint
      only accepts strings containing *no* periods:

      .. _code-block:: python

         Annotated[str, ~Is[lambda text: '.' in text]]

    * **Conjunction** (i.e., ``and``). Conjunctively combining two or more
      :class:`SubscriptedIs` objects with the ``&`` operator synthesizes a new
      :class:`SubscriptedIs` object whose data validator returns ``True`` only
      when all data validators of the original objects return ``True``. For
      example, the following type hint only accepts non-empty strings
      containing *no* periods:

      .. _code-block:: python

         Annotated[str, (
              Is[lambda text: bool(text)] &
             ~Is[lambda text: '.' in text]
         )]

    * **Disjunction** (i.e., ``or``). Disjunctively combining two or more
      subscriptions with the ``|`` operator returns ``True`` only when at least
      one subscription returns ``True``. For example, this type hint accepts
      both empty strings *and* non-empty strings containing at least one
      period:
    * **Disjunction** (i.e., ``or``). Disjunctively combining two or more
      :class:`SubscriptedIs` objects with the ``|`` operator synthesizes a new
      :class:`SubscriptedIs` object whose data validator returns ``True`` only
      when at least one data validator of the original objects returns
      ``True``. For example, the following type hint accepts both empty strings
      *and* non-empty strings containing at least one period:

      .. _code-block:: python

         Annotated[str, (
             ~Is[lambda text: bool(text)] |
              Is[lambda text: '.' in text]
         )]

    See also the **Examples** subsection below.

    Caveats
    ----------
    **This class is currently only supported by the** :func:`beartype.beartype`
    **decorator.** All other static and runtime type checkers silently ignore
    subscriptions of this class subscripting :attr:`typing.Annotated` type
    hints.

    **This class incurs a minor time complexity cost at call time.**
    Specifically, each type hint of a :mod:`beartype`-decorated callable
    subscripted by a subscription of this class adds one additional stack frame
    to each call of that callable. While negligible (in the average case), this
    cost can become non-negligible when compounded across multiple type hints
    annotating a frequently called :mod:`beartype`-decorated callable --
    especially when those type hints are subscripted by multiple subscriptions
    of this class at different nesting levels.

    **This class prohibits instantiation.** This class is *only* intended to be
    subscripted. Attempting to instantiate this class into an object will raise
    an :exc:`BeartypeValeSubscriptedIsInitException` exception.

    Examples
    ----------
    .. _code-block:: python

       from beartype import beartype
       from beartype.vale import Is
       from typing import Annotated

       IsUnquoted = Is[lambda text: '"' not in text and "'" not in text]
       """
       Constraint matching only unquoted strings.
       """

       UnquotedString = Annotated[str, IsUnquoted]
       """
       Type hint matching only unquoted strings.
       """

       @beartype
       def quote_text(text: UnquotedString) -> str:
           """
           Double-quote the passed unquoted string.
           """

           return f'"{text}"'

       IsLengthy = Is[lambda text: 4 <= len(text) <= 14]
       """
       Constraint matching only strings with lengths ranging ``[4, 14]``
       (inclusive).
       """

       UnquotedLengthyString = Annotated[str, IsUnquoted, IsLengthy]
       """
       Type hint matching only unquoted strings with lengths ranging ``[4,
       14]`` (inclusive).
       """

       @beartype
       def snip_text(text: UnquotedLengthyString) -> UnquotedString:
           """
           Return the prefix spanning characters ``[0, 3]`` (inclusive) of the
           passed unquoted string with a length ranging ``[4, 14]``
           (inclusive).
           """

           # "This is guaranteed to work," says beartype.
           return text[:3]

    .. _PEP 593:
       https://www.python.org/dev/peps/pep-0593
    '''

    # ..................{ INITIALIZERS                      }..................
    def __new__(cls, *args, **kwargs):
        '''
        Prohibit direct instantiation by unconditionally raising an exception.

        Like standard type hints (e.g., :attr:`typing.Union`), this class is
        *only* intended to be subscripted (indexed).

        Raises
        ----------
        BeartypeValeSubscriptedIsInitException
            Always.
        '''

        # Murderbot would know what to do here.
        raise BeartypeValeSubscriptedIsInitException(
            f'Class "{cls.__name__}" not instantiable; '
            f'index this class with data validation functions instead '
            f'(e.g., "{cls.__name__}[lambda obj: bool(obj)]").'
        )

    # ..................{ DUNDERS                           }..................
    def __class_getitem__(
        cls, is_valid: SubscriptedIsValidator) -> SubscriptedIs:
        '''
        `PEP 560`_-compliant dunder method dynamically generating a new
        :class:`SubscriptedIs` object from the passed data validation function
        suitable for subscripting `PEP 593`_-compliant :attr:`typing.Annotated`
        type hints.

        See the class docstring for usage instructions.

        Parameters
        ----------
        is_valid : Callable[[Any,], bool]
            **Data validator** (i.e., caller-defined function accepting a
            single arbitrary object and returning either ``True`` if that
            object satisfies an arbitrary constraint *or* ``False`` otherwise).

        Returns
        ----------
        SubscriptedIs
            New object encapsulating this data validator.

        Raises
        ----------
        BeartypeValeSubscriptedIsInitException
            If either:

            * This class was subscripted by two or more arguments.
            * This class was subscripted by one argument that either:

              * Is *not* callable.
              * Is a C-based rather than pure-Python callable.
              * Is a pure-Python callable accepting two or more arguments.

        .. _PEP 560:
           https://www.python.org/dev/peps/pep-0560
        .. _PEP 593:
           https://www.python.org/dev/peps/pep-0593
        '''

        # Dictionary mapping from the name to value of each local attribute
        # referenced in the "is_valid_code" snippet defined below.
        is_valid_code_locals: CallableScope = {}

        # Name of a new parameter added to the signature of each
        # @beartype-decorated wrapper function whose value is this validator,
        # enabling this validator to be called directly in the body of those
        # functions *WITHOUT* imposing additional stack frames.
        is_valid_attr_name = add_func_scope_attr(
            attr=is_valid, attr_scope=is_valid_code_locals)

        # One one-liner to rule them all and in "pdb" bind them.
        return SubscriptedIs(
            is_valid=is_valid,
            # Python code snippet call this validator via that parameter,
            # passed an object to be interpolated into this snippet by
            # downstream logic.
            is_valid_code = f'{is_valid_attr_name}({{obj}})',
            is_valid_code_locals=is_valid_code_locals,
            get_repr=lambda: f'Is[{_get_func_representation(is_valid)}]',
        )

# ....................{ PRIVATE ~ getter                  }....................
def _get_func_representation(func: Callable) -> str:
    '''
    Machine-readable representation of the passed callable.

    Caveats
    ----------
    **This getter is excruciatingly slow.** This getter should *only* be called
    by a caller that is memoizing or otherwise caching the string returned by
    this getter.

    Parameters
    ----------
    func : Callable
        Callable to be represented.

    Warns
    ----------
    BeartypeValeSubscriptedIsLambdaWarning
        If this callable is a pure-Python lambda function whose definition is
        *not* parsable from the script or module defining that lambda.
    '''
    assert callable(func), f'{repr(func)} not callable.'

    # Return either...
    return (
        # If this callable is a pure-Python lambda function, either:
        # * If this lambda is defined by an on-disk script or module source
        #   file, the exact substring of that file defining this lambda.
        # * Else (e.g., if this lambda is dynamically defined in-memory), a
        #   placeholder string.
        get_func_code_or_none(
            func=func,
            warning_cls=BeartypeValeSubscriptedIsLambdaWarning,
        ) or '<lambda>'
        if is_func_lambda(func) else
        # Else, the fully-qualified name of this non-lambda function.
        func.__qualname__
    )
