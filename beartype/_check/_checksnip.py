#!/usr/bin/env python3
# --------------------( LICENSE                            )--------------------
# Copyright (c) 2014-2024 Beartype authors.
# See "LICENSE" for further details.

'''
Project-wide **type-checking function code snippets** (i.e., triple-quoted
pure-Python string constants formatted and concatenated together to dynamically
generate the implementations of functions type-checking arbitrary objects
against arbitrary PEP-compliant type hints).

This private submodule is *not* intended for importation by downstream callers.
'''

# ....................{ IMPORTS                            }....................
from beartype._check.checkmagic import (
    VAR_NAME_PITH_ROOT,
)

# ....................{ CODE ~ signature                   }....................
FUNC_CHECKER_CODE_SIGNATURE = f'''{{code_signature_prefix}}def {{func_name}}(
    {VAR_NAME_PITH_ROOT},
{{code_signature_args}}
):'''
'''
Code snippet declaring the signature of all type-checking tester functions
created by the :func:`beartype._check.checkmagic.make_func_tester` factory.

Note that:

* This signature intentionally:

  * Avoids annotating its parameters or return by type hints. Doing so would be:

    * Pointless, as the type-checking functions dynamically created and returned
      by factory functions defined by the "beartype._check.checkmake" submodule
      are only privately called by the public beartype.door.is_bearable() and
      beartype.door.die_if_unbearable() runtime type-checkers.
    * Harmful, as doing so would prevent this common signature from being
      generically reused as the signature for both raisers and testers.

  * Names the single public parameter accepted by this tester function
    ``{VAR_NAME_PITH_ROOT}``. Doing so trivially ensures that the memoized
    type-checking boolean expression generated by the
    :func:`beartype._check.code.codemake.make_check_expr` code factory
    implicitly type-checks the passed object *without* further modification
    (e.g., global search-and-replacement), ensuring that memoized expression may
    be efficiently reused as is *without* subsequent unmemoization. Clever, huh?

* ``code_signature_prefix`` is usually either:

  * For synchronous callables, the empty string.
  * For asynchronous callables (e.g., asynchronous generators, coroutines), the
    space-suffixed keyword ``"async "``.
'''

# ....................{ CODE ~ return                      }....................
FUNC_TESTER_CODE_RETURN = '''
    # Return true only if the passed object satisfies this type hint.
    return {code_check_expr}'''
'''
Code snippet returning the boolean result of type-checking the arbitrary object
passed to a type-checking tester function against the type hint passed to the
factory function creating that tester function.
'''
