#!/usr/bin/env python3
# --------------------( LICENSE                            )--------------------
# Copyright (c) 2014-2022 Beartype authors.
# See "LICENSE" for further details.

'''
**Beartype type-checking function code factories** (i.e., low-level
callables dynamically generating pure-Python code snippets type-checking
arbitrary objects passed to arbitrary callables against PEP-compliant type hints
passed to those same callables).

This private submodule is *not* intended for importation by downstream callers.
'''

# ....................{ TODO                               }....................
#FIXME: Create a new make_func_raiser_code() factory. After doing so, refactor
#the lower-level beartype._decor._wrapper._wrappercode.make_func_wrapper_code()
#factory in terms of that higher-level make_func_raiser_code() factory, please.
#
#Note that doing so *WILL* prove non-trivial. That's why this submodule has
#currently focused only on the make_func_tester_code() factory. Why the
#non-triviality? Because make_func_raiser_code() will need to embed a substring
#raising an exception by calling a beartype-specific exception handler that does
#*NOT* currently exist. To create that handler, we'll need to:
#* Generalize the existing decoration-specific
#  "beartype._decor._error.errormain" submodule into a new general-purpose
#  "beartype._check._checkerror" submodule. To do so, initially just copy the
#  former to the latter. Do *NOT* bother generalizing any other submodules of
#  the "beartype._decor._error" subpackage, for the moment. One thing at a time.
#* Rename the *COPIED* beartype._check._checkerror.get_beartype_violation()
#  getter to get_func_raiser_violation().
#* Refactor get_func_raiser_violation() to have a signature resembling:
#      def get_func_raiser_violation(
#          # Mandatory parameters.
#          obj: object,
#          hint: object,
#          exception_prefix: str,
#
#          # Optional parameters.
#          random_int: Optional[int] = None,
#      ) -> BeartypeCallHintViolation:
#
#  Crucially, note the new mandatory "exception_prefix" parameter, enabling
#  callers to generate violation exceptions with arbitrary context-specific
#  human-readable prefixes.
#* Shift code currently residing in the BeartypeCall.reinit() method that
#  adds "ARG_NAME_RAISE_EXCEPTION" to "func_wrapper_locals" into the
#  make_func_raiser_code() factory instead.
#* Refactor the original lower-level
#  beartype._decor._error.errormain.get_beartype_violation() getter in terms of
#  the new higher-level get_func_raiser_violation() getter.

# ....................{ IMPORTS                            }....................
from beartype.roar._roarexc import _BeartypeCheckException
from beartype._conf import BeartypeConf
from beartype._data.datatyping import (
    CallableTester,
    TypeException,
)
from beartype._check._expr.exprcode import make_check_expr
# from beartype._util.cache.utilcachecall import callable_cached

#FIXME: Consider shifting the entire "wrappermagic" submodule to a new
#"beartype._check.checkmagic" submodule, please.
from beartype._decor._wrapper.wrappermagic import ARG_NAME_GETRANDBITS

# ....................{ MAKERS                             }....................
#FIXME: Refactor the beartype.abby.is_bearable() tester in terms of this new
#factory, please.
#FIXME: Does this factory benefit from memoization? Probably... not. We already
#memoize the layer immediately below and above this factory. Document this
#justification for *NOT* doing so, please.
# @callable_cached
def make_hint_tester(
    # Mandatory parameters.
    hint: object,

    #FIXME: Docstring us up, please.
    code_prefix: str,
    code_suffix: str,

    # Optional parameters.
    conf: BeartypeConf = BeartypeConf(),
    exception_cls: TypeException = _BeartypeCheckException,
) -> CallableTester:
    '''
    **Type-checking tester function factory** (i.e., low-level callable
    dynamically generating a pure-Python tester function testing whether an
    arbitrary object passed to that tester satisfies the PEP-compliant type hint
    passed to this factory and returning that result as its boolean return).

    This factory is memoized for efficiency.

    Parameters
    ----------
    hint : object
        PEP-compliant type hint to be type-checked.
    conf : BeartypeConf, optional
        **Beartype configuration** (i.e., self-caching dataclass encapsulating
        all settings configuring type-checking for the passed object). Defaults
        to ``BeartypeConf()``, the default ``O(1)`` constant-time configuration.
    exception_cls : Type[Exception]
        Type of exception to be raised. Defaults to
        :exc:`_BeartypeCheckException`.

    Returns
    ----------
    CallableTester
        Type-checking tester function generated by this factory for this hint.

    Raises
    ----------
    All exceptions raised by the lower-level :func:`make_check_expr` factory.
    Additionally, this factory also raises:

    Warns
    ----------
    All warnings emitted by the lower-level :func:`make_check_expr` factory.
    '''
    assert issubclass(exception_cls, Exception), (
        f'{repr(exception_cls)} not exception type.')

    # Python code snippet comprising a single boolean expression type-checking
    # an arbitrary object against this hint.
    (
        code_expr,
        func_locals,
        hint_forwardrefs_class_basename,
    ) = make_check_expr(hint)

    # If this hint contains one or more relative forward references, this hint
    # is non-portable across lexical scopes. Why? Because this hint is relative
    # to and thus valid only with respect to the caller's current lexical scope.
    # However, there is *NO* guarantee that the tester function created and
    # returned by this factory resides in the same lexical scope.
    #
    # Suppose that tester does, however. Even in that best case, *ALL* calls to
    # that tester would still be non-portable. Why? Because those calls would
    # now tacitly assume the original lexical scope that they were called in.
    # Those calls are now lexically-dependent and thus could *NOT* be trivially
    # copy-and-pasted into different lexical scopes (e.g., submodules, classes,
    # or callables); doing so would raise exceptions at call time, due to being
    # unable to resolve those references. Preventing users from doing something
    # that will blow up in their test suites commits after the fact is not
    # simply a good thing; it's really the only sane thing left.
    #
    # Suppose that we didn't particularly care about end user sanity, however.
    # Even in that worst case, resolving these references would still be
    # non-trivial, non-portable, and (perhaps most importantly) incredibly slow.
    # Why? Because doing so would require iteratively introspecting the call
    # stack for the first callable *NOT* residing in the "beartype" codebase.
    # These references would then be resolved against the global and local
    # lexical scope of that callable. While technically feasible, doing so would
    # render higher-level "beartype" functions calling this lower-level
    # factory (e.g., our increasingly popular public beartype.abby.is_bearable()
    # tester) sufficiently slow as to be pragmatically infeasible.
    if hint_forwardrefs_class_basename:
        raise exception_cls(
            f'Type hint {repr(hint)} contains one or more relative forward '
            f'references:\n\t{repr(hint_forwardrefs_class_basename)}\n'
            f'Beartype prohibits relative forward references outside of '
            f'@beartype-decorated callables. For your own personal safety and '
            f'those of the codebases you love, consider canonicalizing these '
            f'relative forward references into absolute forward references '
            f'(e.g., from "MuhClass" into "muh_module.MuhClass").'
        )
    # Else, this hint contains *NO* relative forward references.

    #FIXME: Insufficient. We'll also need to generalize the
    #"CODE_INIT_RANDOM_INT" snippet out of "wrappermain" and into this function.
    #FIXME: Indeed. It increasingly looks like we want to generalize the
    #_make_func_wrapper_signature() factory into a new public
    #beartype._check._checkcode.make_func_signature() factory. That function is
    #sufficiently useful to warrant generalization. Note that doing so will be
    #slightly non-trivial, as _make_func_wrapper_signature() is currently only
    #passed "BeartypeCall". We do *NOT* want to bother creating and passing a
    #new "BeartypeCall" instance here. So, we'll need to generalize
    #make_func_signature() to accept *ALL* of the "BeartypeCall" instance
    #variables referenced in that factory as parameters of that factory. *sigh*
    #
    #Then replace the existing call to _make_func_wrapper_signature() in
    #"wrappermain" with a call to make_func_signature().

    # Python code snippet type-checking the root pith against the root hint.
    hint_tester_code = (
        f'{code_prefix}'
        f'{code_expr}'
        f'{code_suffix}'
    )

    #FIXME: Call make_func() here, please.
    hint_tester = lambda obj: True

    # Return this tester, please.
    return hint_tester
